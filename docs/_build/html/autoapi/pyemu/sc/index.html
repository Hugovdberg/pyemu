

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyemu.sc &mdash; pyEMU 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> pyEMU
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyemu.sc</span></code></a><ul>
<li><a class="reference internal" href="#module-contents">Module Contents</a><ul>
<li><a class="reference internal" href="#classes">Classes</a><ul>
<li><a class="reference internal" href="#pyemu.sc.Schur">Schur</a><ul>
<li><a class="reference internal" href="#pyemu.sc.Schur.posterior_parameter">posterior_parameter</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.posterior_forecast">posterior_forecast</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.posterior_prediction">posterior_prediction</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.get_parameter_summary">get_parameter_summary</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.get_forecast_summary">get_forecast_summary</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.__contribution_from_parameters">__contribution_from_parameters</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.get_conditional_instance">get_conditional_instance</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.get_par_contribution">get_par_contribution</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.get_par_group_contribution">get_par_group_contribution</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.get_added_obs_importance">get_added_obs_importance</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.get_removed_obs_importance">get_removed_obs_importance</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.get_obs_group_dict">get_obs_group_dict</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.get_removed_obs_group_importance">get_removed_obs_group_importance</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.get_added_obs_group_importance">get_added_obs_group_importance</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.next_most_important_added_obs">next_most_important_added_obs</a></li>
<li><a class="reference internal" href="#pyemu.sc.Schur.next_most_par_contribution">next_most_par_contribution</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyEMU</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyemu.sc</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/autoapi/pyemu/sc/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pyemu.sc">
<span id="pyemu-sc"></span><h1><a class="reference internal" href="../../../pyemu.html#module-pyemu.sc" title="pyemu.sc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyemu.sc</span></code></a><a class="headerlink" href="#module-pyemu.sc" title="Permalink to this headline">¶</a></h1>
<p>module for FOSM-based uncertainty analysis using a
linearized form of Bayes equation known as the Schur compliment</p>
<div class="section" id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../../../pyemu.html#pyemu.sc.Schur" title="pyemu.sc.Schur"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Schur</span></code></a></p></td>
<td><p>FOSM-based uncertainty and data-worth analysis</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="pyemu.sc.Schur">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.sc.</code><code class="sig-name descname">Schur</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">jco</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../../../pyemu.html#pyemu.la.LinearAnalysis" title="pyemu.la.LinearAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyemu.la.LinearAnalysis</span></code></a></p>
<p>FOSM-based uncertainty and data-worth analysis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>jco</strong> (<em>varies</em><em>, </em><em>optional</em>) – something that can be cast or loaded into a <cite>pyemu.Jco</cite>.  Can be a
str for a filename or <cite>pyemu.Matrix</cite>/<cite>pyemu.Jco</cite> object.</p></li>
<li><p><strong>pst</strong> (<em>varies</em><em>, </em><em>optional</em>) – something that can be cast into a <cite>pyemu.Pst</cite>.  Can be an <cite>str</cite> for a
filename or an existing <cite>pyemu.Pst</cite>.  If <cite>None</cite>, a pst filename is sought
with the same base name as the jco argument (if passed)</p></li>
<li><p><strong>parcov</strong> (<em>varies</em><em>, </em><em>optional</em>) – prior parameter covariance matrix.  If <cite>str</cite>, a filename is assumed and
the prior parameter covariance matrix is loaded from a file using
the file extension (“.jcb”/”.jco” for binary, “.cov”/”.mat” for PEST-style ASCII matrix,
or “.unc” for uncertainty files).  If <cite>None</cite>, the prior parameter covariance matrix is
constructed from the parameter bounds in <cite>LinearAnalysis.pst</cite>.  Can also be a <cite>pyemu.Cov</cite> instance</p></li>
<li><p><strong>obscov</strong> (<em>varies</em><em>, </em><em>optional</em>) – observation noise covariance matrix.  If <cite>str</cite>, a filename is assumed and
the noise covariance matrix is loaded from a file using
the file extension (“.jcb”/”.jco” for binary, “.cov”/”.mat” for PEST-style ASCII matrix,
or “.unc” for uncertainty files).  If <cite>None</cite>, the noise covariance matrix is
constructed from the obsevation weights in <cite>LinearAnalysis.pst</cite>.  Can also be a <cite>pyemu.Cov</cite> instance</p></li>
<li><p><strong>forecasts</strong> (<em>varies</em><em>, </em><em>optional</em>) – forecast sensitivity vectors.  If <cite>str</cite>, first an observation name is assumed (a row
in <cite>LinearAnalysis.jco</cite>).  If that is not found, a filename is assumed and predictions are
loaded from a file using the file extension.  If [<cite>str</cite>], a list of observation names is assumed.
Can also be a <cite>pyemu.Matrix</cite> instance, a <cite>numpy.ndarray</cite> or a collection.  Note if the PEST++ option
“++forecasts()” is set in the pest control file (under the <cite>pyemu.Pst.pestpp_options</cite> dictionary),
then there is no need to pass this argument (unless you want to analyze different forecasts)
of <cite>pyemu.Matrix</cite> or <cite>numpy.ndarray</cite>.</p></li>
<li><p><strong>ref_var</strong> (<em>float</em><em>, </em><em>optional</em>) – reference variance.  Default is 1.0</p></li>
<li><p><strong>verbose</strong> (<cite>bool</cite>) – controls screen output.  If <cite>str</cite>, a filename is assumed and
and log file is written.</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>, optional) – defines range of upper bound - lower bound in terms of standard
deviation (sigma). For example, if sigma_range = 4, the bounds represent 4 * sigma.
Default is 4.0, representing approximately 95% confidence of implied normal distribution.
This arg is only used if constructing parcov from parameter bounds.</p></li>
<li><p><strong>scale_offset</strong> (<cite>bool</cite>, optional) – flag to apply parameter scale and offset to parameter bounds
when calculating prior parameter covariance matrix from bounds.  This arg is onlyused if
constructing parcov from parameter bounds.Default is True.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is the primary entry point for FOSM-based uncertainty and
dataworth analyses</p>
<p>This class replicates and extends the behavior of the PEST PREDUNC utilities.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#assumes &quot;my.pst&quot; exists</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">,</span><span class="n">forecasts</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;fore1&quot;</span><span class="p">,</span><span class="s2">&quot;fore2&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">get_forecast_summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">get_parameter_contribution</span><span class="p">())</span>
</pre></div>
</div>
<dl class="py method">
<dt id="pyemu.sc.Schur.posterior_parameter">
<em class="property">property </em><code class="sig-name descname">posterior_parameter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.posterior_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>posterior parameter covariance matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the posterior parameter covariance matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jcb&quot;</span><span class="p">)</span>
<span class="n">post_cov</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">posterior_parameter</span>
<span class="n">post_cov</span><span class="o">.</span><span class="n">to_ascii</span><span class="p">(</span><span class="s2">&quot;post.cov&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.posterior_forecast">
<em class="property">property </em><code class="sig-name descname">posterior_forecast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.posterior_forecast" title="Permalink to this definition">¶</a></dt>
<dd><p>posterior forecast (e.g. prediction) variance(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of forecast names and FOSM-estimated posterior
variances</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sames as <cite>LinearAnalysis.posterior_prediction</cite></p>
<p>See <cite>Schur.get_forecast_summary()</cite> for a dataframe-based container of prior and posterior
variances</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.posterior_prediction">
<em class="property">property </em><code class="sig-name descname">posterior_prediction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.posterior_prediction" title="Permalink to this definition">¶</a></dt>
<dd><p>posterior prediction (e.g. forecast) variance estimate(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of forecast names and FOSM-estimated posterior
variances</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><p><cite>dict</cite></p>
<dl>
<dt>Note:</dt><dd><p>sames as <cite>LinearAnalysis.posterior_forecast</cite></p>
<p>See <cite>Schur.get_forecast_summary()</cite> for a dataframe-based container of prior and posterior
variances</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.get_parameter_summary">
<code class="sig-name descname">get_parameter_summary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_parameter_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>summary of the FOSM-based parameter uncertainty (variance) estimate(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dataframe of prior,posterior variances and percent
uncertainty reduction of each parameter</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the primary entry point for accessing parameter uncertainty estimates</p>
<p>The “Prior” column in dataframe is the diagonal of <cite>LinearAnalysis.parcov</cite>
“precent_reduction” column in dataframe is calculated as 100.0 * (1.0 -
(posterior variance / prior variance)</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jcb&quot;</span><span class="p">,</span><span class="n">forecasts</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;fore1&quot;</span><span class="p">,</span><span class="s2">&quot;fore2&quot;</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_parameter_summary</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s2">&quot;prior&quot;</span><span class="p">,</span><span class="s2">&quot;posterior&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">percent_reduction</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.get_forecast_summary">
<code class="sig-name descname">get_forecast_summary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_forecast_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>summary of the FOSM-based forecast uncertainty (variance) estimate(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dataframe of prior,posterior variances and percent
uncertainty reduction of each forecast (e.g. prediction)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the primary entry point for accessing forecast uncertainty estimates
“precent_reduction” column in dataframe is calculated as
100.0 * (1.0 - (posterior variance / prior variance)</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jcb&quot;</span><span class="p">,</span><span class="n">forecasts</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;fore1&quot;</span><span class="p">,</span><span class="s2">&quot;fore2&quot;</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_parameter_summary</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s2">&quot;prior&quot;</span><span class="p">,</span><span class="s2">&quot;posterior&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">percent_reduction</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.__contribution_from_parameters">
<code class="sig-name descname">__contribution_from_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">parameter_names</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.__contribution_from_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>private method get the prior and posterior uncertainty reduction as a result of
some parameter becoming perfectly known</p>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.get_conditional_instance">
<code class="sig-name descname">get_conditional_instance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">parameter_names</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_conditional_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>get a new <cite>pyemu.Schur</cite> instance that includes conditional update from
some parameters becoming known perfectly</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>parameter_names</strong> ([<cite>str</cite>]) – list of parameters that are to be treated as
notionally perfectly known</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new Schur instance conditional on perfect knowledge
of some parameters. The new instance has an updated <cite>parcov</cite> that is less
the names listed in <cite>parameter_names</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Schur</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is primarily for use by the <cite>LinearAnalysis.get_parameter_contribution()</cite>
dataworth method.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.get_par_contribution">
<code class="sig-name descname">get_par_contribution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">parlist_dict</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">include_prior_results</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_par_contribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A dataworth method to get a dataframe the prior and posterior uncertainty
reduction as a result of some parameter becoming perfectly known</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parlist_dict</strong> – (<cite>dict</cite>, optional): a nested dictionary-list of groups of parameters
that are to be treated as perfectly known.  key values become
row labels in returned dataframe.  If <cite>None</cite>, each adjustable parameter
is sequentially treated as known and the returned dataframe
has row labels for each adjustable parameter</p></li>
<li><p><strong>include_prior_results</strong> (<cite>bool</cite>, optional) – flag to return a multi-indexed dataframe with both conditional
prior and posterior forecast uncertainty estimates.  This is because
the notional learning about parameters potentially effects both the prior
and posterior forecast uncertainty estimates. If <cite>False</cite>, only posterior
results are returned.  Default is <cite>False</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe that summarizes the parameter contribution
dataworth analysis. The dataframe has index (row labels) of the keys in parlist_dict
and a column labels of forecast names.  The values in the dataframe
are the posterior variance of the forecast conditional on perfect
knowledge of the parameters in the values of parlist_dict.  One row in the
dataframe will be labeled <cite>base</cite> - this is the forecast uncertainty estimates
that include the effects of all adjustable parameters.  Percent decreases in
forecast uncertainty can be calculated by differencing all rows against the
“base” row.  Varies depending on <cite>include_prior_results</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the primary dataworth method for assessing the contribution of one or more
parameters to forecast uncertainty.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">parlist_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;hk&quot;</span><span class="p">:[</span><span class="s2">&quot;hk1&quot;</span><span class="p">,</span><span class="s2">&quot;hk2&quot;</span><span class="p">],</span><span class="s2">&quot;rech&quot;</span><span class="p">[</span><span class="s2">&quot;rech1&quot;</span><span class="p">,</span><span class="s2">&quot;rech2&quot;</span><span class="p">]}</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_par_contribution</span><span class="p">(</span><span class="n">parlist_dict</span><span class="o">=</span><span class="n">parlist_dict</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.get_par_group_contribution">
<code class="sig-name descname">get_par_group_contribution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">include_prior_results</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_par_group_contribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A dataworth method to get the forecast uncertainty contribution from each parameter
group</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>include_prior_results</strong> (<cite>bool</cite>, optional) – flag to return a multi-indexed dataframe with both conditional
prior and posterior forecast uncertainty estimates.  This is because
the notional learning about parameters potentially effects both the prior
and posterior forecast uncertainty estimates. If <cite>False</cite>, only posterior
results are returned.  Default is <cite>False</cite></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe that summarizes the parameter contribution analysis.
The dataframe has index (row labels) that are the parameter group names
and a column labels of forecast names.  The values in the dataframe
are the posterior variance of the forecast conditional on perfect
knowledge of the adjustable parameters in each parameter group.  One
row is labelled “base” - this is the variance of the forecasts that includes
the effects of all adjustable parameters. Varies depending on <cite>include_prior_results</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is just a thin wrapper around get_contribution_dataframe() - this method
automatically constructs the parlist_dict argument where the keys are the
group names and the values are the adjustable parameters in the groups</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_par_group_contribution</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.get_added_obs_importance">
<code class="sig-name descname">get_added_obs_importance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">obslist_dict</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">base_obslist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reset_zero_weight</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_added_obs_importance" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A dataworth method to analyze the posterior uncertainty as a result of gathering</dt><dd><p>some additional observations</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obslist_dict</strong> (<cite>dict</cite>, optional) – a nested dictionary-list of groups of observations
that are to be treated as gained/collected.  key values become
row labels in returned dataframe. If <cite>None</cite>, then every zero-weighted
observation is tested sequentially. Default is <cite>None</cite></p></li>
<li><p><strong>base_obslist</strong> ([<cite>str</cite>], optional) – observation names to treat as the “existing” observations.
The values of <cite>obslist_dict</cite> will be added to this list during
each test.  If <cite>None</cite>, then the values in each <cite>obslist_dict</cite> entry will
be treated as the entire calibration dataset.  That is, there
are no existing observations. Default is <cite>None</cite>.  Standard practice would
be to pass this argument as <cite>pyemu.Schur.pst.nnz_obs_names</cite> so that existing,
non-zero-weighted observations are accounted for in evaluating the worth of
new yet-to-be-collected observations.</p></li>
<li><p><strong>reset_zero_weight</strong> (<cite>bool</cite>, optional) – a flag to reset observations with zero weight in either
<cite>obslist_dict</cite> or <cite>base_obslist</cite>. If <cite>reset_zero_weights</cite>
passed as a <cite>float</cite>,then that value will be assigned to
zero weight obs.  Otherwise, zero-weight obs will be given a
weight of 1.0.  Default is <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with row labels (index) of <cite>obslist_dict.keys()</cite> and
columns of forecast names.  The values in the dataframe are the
posterior variance of the forecasts resulting from notional inversion
using the observations in <cite>obslist_dict[key value]</cite> plus the observations
in <cite>base_obslist</cite> (if any).  One row in the dataframe is labeled “base” - this is
posterior forecast variance resulting from the notional calibration with the
observations in <cite>base_obslist</cite> (if <cite>base_obslist</cite> is <cite>None</cite>, then the “base” row is the
prior forecast variance).  Conceptually, the forecast variance should either not change or
decrease as a result of gaining additional observations.  The magnitude of the decrease
represents the worth of the potential new observation(s) being tested.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Observations listed in <cite>obslist_dict</cite> and <cite>base_obslist</cite> with zero
weights are not included in the analysis unless <cite>reset_zero_weight</cite> is <cite>True</cite> or a float
greater than zero.  In most cases, users will want to reset zero-weighted observations as part
dataworth testing process.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">obslist_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;hds&quot;</span><span class="p">:[</span><span class="s2">&quot;head1&quot;</span><span class="p">,</span><span class="s2">&quot;head2&quot;</span><span class="p">],</span><span class="s2">&quot;flux&quot;</span><span class="p">:[</span><span class="s2">&quot;flux1&quot;</span><span class="p">,</span><span class="s2">&quot;flux2&quot;</span><span class="p">]}</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_added_obs_importance</span><span class="p">(</span><span class="n">obslist_dict</span><span class="o">=</span><span class="n">obslist_dict</span><span class="p">,</span>
                                 <span class="n">base_obslist</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">pst</span><span class="o">.</span><span class="n">nnz_obs_names</span><span class="p">,</span>
                                 <span class="n">reset_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.get_removed_obs_importance">
<code class="sig-name descname">get_removed_obs_importance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">obslist_dict</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reset_zero_weight</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_removed_obs_importance" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A dataworth method to analyze the posterior uncertainty as a result of losing</dt><dd><p>some existing observations</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obslist_dict</strong> (<cite>dict</cite>, optional) – a nested dictionary-list of groups of observations
that are to be treated as lost.  key values become
row labels in returned dataframe. If <cite>None</cite>, then every zero-weighted
observation is tested sequentially. Default is <cite>None</cite></p></li>
<li><p><strong>reset_zero_weight</strong> (<cite>bool</cite>, optional) – a flag to reset observations with zero weight in either
<cite>obslist_dict</cite> or <cite>base_obslist</cite>. If <cite>reset_zero_weights</cite>
passed as a <cite>float</cite>,then that value will be assigned to
zero weight obs.  Otherwise, zero-weight obs will be given a
weight of 1.0.  Default is <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dataframe with index of obslist_dict.keys() and columns
of forecast names.  The values in the dataframe are the posterior
variances of the forecasts resulting from losing the information
contained in obslist_dict[key value]. One row in the dataframe is labeled “base” - this is
posterior forecast variance resulting from the notional calibration with the
non-zero-weighed observations in <cite>Schur.pst</cite>.  Conceptually, the forecast variance should
either not change or increase as a result of losing existing observations.  The magnitude
of the increase represents the worth of the existing observation(s) being tested.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Observations listed in <cite>obslist_dict</cite> and <cite>base_obslist</cite> with zero
weights are not included in the analysis unless <cite>reset_zero_weight</cite> is <cite>True</cite> or a float
greater than zero.  In most cases, users will want to reset zero-weighted observations as part
dataworth testing process.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_removed_obs_importance</span><span class="p">(</span><span class="n">reset_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.get_obs_group_dict">
<code class="sig-name descname">get_obs_group_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_obs_group_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>get a dictionary of observations grouped by observation group name</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dictionary of observations grouped by observation group name.
Useful for dataworth processing in <cite>pyemu.Schur</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>only includes observations that are listed in <cite>Schur.jco.row_names</cite></p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">obsgrp_dict</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_obs_group_dict</span><span class="p">()</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_removed_obs_importance</span><span class="p">(</span><span class="n">obsgrp_dict</span><span class="o">=</span><span class="n">obsgrp_dict</span><span class="p">,</span> <span class="n">reset_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.get_removed_obs_group_importance">
<code class="sig-name descname">get_removed_obs_group_importance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">reset_zero_weight</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_removed_obs_group_importance" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A dataworth method to analyze the posterior uncertainty as a result of losing</dt><dd><p>existing observations, tested by observation groups</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>reset_zero_weight</strong> (<cite>bool</cite>, optional) – a flag to reset observations with zero weight in either
<cite>obslist_dict</cite> or <cite>base_obslist</cite>. If <cite>reset_zero_weights</cite>
passed as a <cite>float</cite>,then that value will be assigned to
zero weight obs.  Otherwise, zero-weight obs will be given a
weight of 1.0.  Default is <cite>False</cite>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dataframe with index of observation group names and columns
of forecast names.  The values in the dataframe are the posterior
variances of the forecasts resulting from losing the information
contained in each observation group. One row in the dataframe is labeled “base” - this is
posterior forecast variance resulting from the notional calibration with the
non-zero-weighed observations in <cite>Schur.pst</cite>.  Conceptually, the forecast variance should
either not change or increase as a result of losing existing observations.  The magnitude
of the increase represents the worth of the existing observation(s) in each group being tested.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Observations in <cite>Schur.pst</cite> with zero weights are not included in the analysis unless
<cite>reset_zero_weight</cite> is <cite>True</cite> or a float greater than zero.  In most cases, users
will want to reset zero-weighted observations as part dataworth testing process.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_removed_obs_group_importance</span><span class="p">(</span><span class="n">reset_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.get_added_obs_group_importance">
<code class="sig-name descname">get_added_obs_group_importance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">reset_zero_weight</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_added_obs_group_importance" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A dataworth method to analyze the posterior uncertainty as a result of gaining</dt><dd><p>existing observations, tested by observation groups</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>reset_zero_weight</strong> (<cite>bool</cite>, optional) – a flag to reset observations with zero weight in either
<cite>obslist_dict</cite> or <cite>base_obslist</cite>. If <cite>reset_zero_weights</cite>
passed as a <cite>float</cite>,then that value will be assigned to
zero weight obs.  Otherwise, zero-weight obs will be given a
weight of 1.0.  Default is <cite>False</cite>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dataframe with index of observation group names and columns
of forecast names.  The values in the dataframe are the posterior
variances of the forecasts resulting from gaining the information
contained in each observation group. One row in the dataframe is labeled “base” - this is
posterior forecast variance resulting from the notional calibration with the
non-zero-weighed observations in <cite>Schur.pst</cite>.  Conceptually, the forecast variance should
either not change or decrease as a result of gaining new observations.  The magnitude
of the decrease represents the worth of the potential new observation(s) in each group
being tested.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Observations in <cite>Schur.pst</cite> with zero weights are not included in the analysis unless
<cite>reset_zero_weight</cite> is <cite>True</cite> or a float greater than zero.  In most cases, users
will want to reset zero-weighted observations as part dataworth testing process.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_added_obs_group_importance</span><span class="p">(</span><span class="n">reset_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.next_most_important_added_obs">
<code class="sig-name descname">next_most_important_added_obs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">forecast</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">niter</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">obslist_dict</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">base_obslist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reset_zero_weight</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.next_most_important_added_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>find the most important observation(s) by sequentially evaluating
the importance of the observations in <cite>obslist_dict</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>forecast</strong> (<cite>str</cite>, optional) – name of the forecast to use in the ranking process.  If
more than one forecast has been listed, this argument is required.  This is because
the data worth must be ranked with respect to the variance reduction for a single
forecast</p></li>
<li><p><strong>niter</strong> (<cite>int</cite>, optional) – number of sequential dataworth testing iterations.  Default is 3</p></li>
<li><p><strong>obslist_dict</strong> (<cite>dict</cite>, optional) – a nested dictionary-list of groups of observations
that are to be treated as gained/collected.  key values become
row labels in returned dataframe. If <cite>None</cite>, then every zero-weighted
observation is tested sequentially. Default is <cite>None</cite></p></li>
<li><p><strong>base_obslist</strong> ([<cite>str</cite>], optional) – observation names to treat as the “existing” observations.
The values of <cite>obslist_dict</cite> will be added to this list during
each test.  If <cite>None</cite>, then the values in each <cite>obslist_dict</cite> entry will
be treated as the entire calibration dataset.  That is, there
are no existing observations. Default is <cite>None</cite>.  Standard practice would
be to pass this argument as <cite>pyemu.Schur.pst.nnz_obs_names</cite> so that existing,
non-zero-weighted observations are accounted for in evaluating the worth of
new yet-to-be-collected observations.</p></li>
<li><p><strong>reset_zero_weight</strong> (<cite>bool</cite>, optional) – a flag to reset observations with zero weight in either
<cite>obslist_dict</cite> or <cite>base_obslist</cite>. If <cite>reset_zero_weights</cite>
passed as a <cite>float</cite>,then that value will be assigned to
zero weight obs.  Otherwise, zero-weight obs will be given a
weight of 1.0.  Default is <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataFrame with columns of <cite>obslist_dict</cite> key for each iteration
the yields the largest variance reduction for the named <cite>forecast</cite>. Columns are forecast
variance percent reduction for each iteration (percent reduction compared to initial “base”
case with all non-zero weighted observations included in the notional calibration)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The most important observations from each iteration is added to <cite>base_obslist</cite>
and removed <cite>obslist_dict</cite> for the next iteration.  In this way, the added
observation importance values include the conditional information from
the last iteration.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">next_most_important_added_obs</span><span class="p">(</span><span class="n">forecast</span><span class="o">=</span><span class="s2">&quot;fore1&quot;</span><span class="p">,</span><span class="n">base_obslist</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">pst</span><span class="o">.</span><span class="n">nnz_obs_names</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyemu.sc.Schur.next_most_par_contribution">
<code class="sig-name descname">next_most_par_contribution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">niter</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">forecast</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">parlist_dict</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.next_most_par_contribution" title="Permalink to this definition">¶</a></dt>
<dd><p>find the parameter(s) contributing most to posterior
forecast  by sequentially evaluating the contribution of parameters in
<cite>parlist_dict</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>forecast</strong> (<cite>str</cite>, optional) – name of the forecast to use in the ranking process.  If
more than one forecast has been listed, this argument is required.  This is because
the data worth must be ranked with respect to the variance reduction for a single
forecast</p></li>
<li><p><strong>niter</strong> (<cite>int</cite>, optional) – number of sequential dataworth testing iterations.  Default is 3</p></li>
<li><p><strong>parlist_dict</strong> (<cite>dict</cite>, optional) – dict
a nested dictionary-list of groups of parameters
that are to be treated as perfectly known.  key values become
row labels in dataframe</p></li>
<li><p><strong>parlist_dict</strong> – a nested dictionary-list of groups of parameters
that are to be treated as perfectly known (zero uncertainty).  key values become
row labels in returned dataframe. If <cite>None</cite>, then every adustable parameter is tested
sequentially. Default is <cite>None</cite>. Conceptually, the forecast variance should
either not change or decrease as a result of knowing parameter perfectly.  The magnitude
of the decrease represents the worth of gathering information about the parameter(s) being
tested.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The largest contributing parameters from each iteration are
treated as known perfectly for the remaining iterations.  In this way, the
next iteration seeks the next most influential group of parameters.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe with index of iteration number and columns
of <cite>parlist_dict.keys()</cite>.  The values are the results of the knowing
each parlist_dict entry expressed as posterior variance reduction</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Jeremy White, Mike Fienen, Brioch Hemmings, and others

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>