:mod:`pyemu`
============

.. py:module:: pyemu

.. autoapi-nested-parse::

   pyEMU: python modules for Environmental Model Uncertainty analyses.  These
   modules are designed to work directly and seamlessly with PEST and PEST++ model
   independent interface.  pyEMU can also be used to setup this interface.

   Several forms of uncertainty analyses are support including FOSM-based
   analyses (pyemu.Schur and pyemu.ErrVar), data worth analyses and
   high-dimensional ensemble generation.



Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   mat/index.rst
   plot/index.rst
   prototypes/index.rst
   pst/index.rst
   utils/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   _version/index.rst
   en/index.rst
   ev/index.rst
   la/index.rst
   logger/index.rst
   mc/index.rst
   pyemu_warnings/index.rst
   sc/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   pyemu.LinearAnalysis
   pyemu.Schur
   pyemu.ErrVar
   pyemu.Ensemble
   pyemu.ParameterEnsemble
   pyemu.ObservationEnsemble
   pyemu.Matrix
   pyemu.Jco
   pyemu.Cov
   pyemu.Pst
   pyemu.ParameterEnsemble
   pyemu.ObservationEnsemble
   pyemu.Cov
   pyemu.Matrix
   pyemu.Pst



.. py:class:: LinearAnalysis(jco=None, pst=None, parcov=None, obscov=None, predictions=None, ref_var=1.0, verbose=False, resfile=False, forecasts=None, sigma_range=4.0, scale_offset=True, **kwargs)

   Bases: :class:`object`

   The base/parent class for linear analysis.

   :param jco: something that can be cast or loaded into a `pyemu.Jco`.  Can be a
               str for a filename or `pyemu.Matrix`/`pyemu.Jco` object.
   :type jco: varies, optional
   :param pst: something that can be cast into a `pyemu.Pst`.  Can be an `str` for a
               filename or an existing `pyemu.Pst`.  If `None`, a pst filename is sought
               with the same base name as the jco argument (if passed)
   :type pst: varies, optional
   :param parcov: prior parameter covariance matrix.  If `str`, a filename is assumed and
                  the prior parameter covariance matrix is loaded from a file using
                  the file extension (".jcb"/".jco" for binary, ".cov"/".mat" for PEST-style ASCII matrix,
                  or ".unc" for uncertainty files).  If `None`, the prior parameter covariance matrix is
                  constructed from the parameter bounds in `LinearAnalysis.pst`.  Can also be a `pyemu.Cov` instance
   :type parcov: varies, optional
   :param obscov: observation noise covariance matrix.  If `str`, a filename is assumed and
                  the noise covariance matrix is loaded from a file using
                  the file extension (".jcb"/".jco" for binary, ".cov"/".mat" for PEST-style ASCII matrix,
                  or ".unc" for uncertainty files).  If `None`, the noise covariance matrix is
                  constructed from the obsevation weights in `LinearAnalysis.pst`.  Can also be a `pyemu.Cov` instance
   :type obscov: varies, optional
   :param forecasts: forecast sensitivity vectors.  If `str`, first an observation name is assumed (a row
                     in `LinearAnalysis.jco`).  If that is not found, a filename is assumed and predictions are
                     loaded from a file using the file extension.  If [`str`], a list of observation names is assumed.
                     Can also be a `pyemu.Matrix` instance, a `numpy.ndarray` or a collection
                     of `pyemu.Matrix` or `numpy.ndarray`.
   :type forecasts: varies, optional
   :param ref_var: reference variance.  Default is 1.0
   :type ref_var: float, optional
   :param verbose: controls screen output.  If `str`, a filename is assumed and
                   and log file is written.
   :type verbose: `bool`
   :param sigma_range: defines range of upper bound - lower bound in terms of standard
                       deviation (sigma). For example, if sigma_range = 4, the bounds represent 4 * sigma.
                       Default is 4.0, representing approximately 95% confidence of implied normal distribution.
                       This arg is only used if constructing parcov from parameter bounds.
   :type sigma_range: `float`, optional
   :param scale_offset: flag to apply parameter scale and offset to parameter bounds
                        when calculating prior parameter covariance matrix from bounds.  This arg is onlyused if
                        constructing parcov from parameter bounds.Default is True.
   :type scale_offset: `bool`, optional

   .. note::

      Can be used directly, but for prior uncertainty analyses only.
      
      The derived types (`pyemu.Schur`, `pyemu.ErrVar`) are for different
      forms of FOMS-based posterior uncertainty analyses.
      
      This class tries hard to not load items until they are needed; all arguments are optional.
      
      The class makes heavy use of property decorator to encapsulated private attributes

   Example::

       #assumes "my.pst" exists
       la = pyemu.LinearAnalysis(jco="my.jco",forecasts=["fore1","fore2"])
       print(la.prior_forecast)


   .. method:: __fromfile(self, filename, astype=None)

      a private method to deduce and load a filename into a matrix object.
      Uses extension: 'jco' or 'jcb': binary, 'mat','vec' or 'cov': ASCII,
      'unc': pest uncertainty file.


   .. method:: __load_pst(self)

      private method set the pst attribute


   .. method:: __load_jco(self)

      private method to set the jco attribute from a file or a matrix object


   .. method:: __load_parcov(self)

      private method to set the parcov attribute from:
      a pest control file (parameter bounds)
      a pst object
      a matrix object
      an uncert file
      an ascii matrix file


   .. method:: __load_obscov(self)

      private method to set the obscov attribute from:
      a pest control file (observation weights)
      a pst object
      a matrix object
      an uncert file
      an ascii matrix file


   .. method:: __load_predictions(self)

      private method set the predictions attribute from:
          mixed list of row names, matrix files and ndarrays
          a single row name
          an ascii file
      can be none if only interested in parameters.


   .. method:: forecast_names(self)
      :property:

      get the forecast (aka prediction) names

      :returns: list of forecast names
      :rtype: ([`str`])


   .. method:: parcov(self)
      :property:

      get the prior parameter covariance matrix attribute

      :returns: a reference to the `LinearAnalysis.parcov` attribute
      :rtype: `pyemu.Cov`


   .. method:: obscov(self)
      :property:

      get the observation noise covariance matrix attribute

      :returns: a reference to the `LinearAnalysis.obscov` attribute
      :rtype: `pyemu.Cov`


   .. method:: nnz_obs_names(self)
      :property:

      non-zero-weighted observation names

      :returns: list of non-zero-weighted observation names
      :rtype: ['str`]

      .. note:: if `LinearAnalysis.pst` is `None`, returns `LinearAnalysis.jco.row_names`


   .. method:: adj_par_names(self)
      :property:

      adjustable parameter names

      :returns: list of adjustable parameter names
      :rtype: ['str`]

      .. note:: if `LinearAnalysis.pst` is `None`, returns `LinearAnalysis.jco.col_names`


   .. method:: jco(self)
      :property:

      the jacobian matrix attribute

      :returns: the jacobian matrix attribute
      :rtype: `pyemu.Jco`


   .. method:: predictions(self)
      :property:

      the prediction (aka forecast) sentivity vectors attribute

      :returns: a matrix of prediction sensitivity vectors (column wise)
      :rtype: `pyemu.Matrix`


   .. method:: predictions_iter(self)
      :property:

      prediction sensitivity vectors iterator

      :returns: iterator on prediction sensitivity vectors (matrix)
      :rtype: `iterator`

      .. note:: this is used for processing huge numbers of predictions


   .. method:: forecasts_iter(self)
      :property:

      forecast (e.g. prediction) sensitivity vectors iterator

      :returns: iterator on forecasts (e.g. predictions) sensitivity vectors (matrix)
      :rtype: `iterator`

      .. note::

         This is used for processing huge numbers of predictions
         
         This is a synonym for LinearAnalysis.predictions_iter()


   .. method:: forecasts(self)
      :property:

      the forecast sentivity vectors attribute

      :returns: a matrix of forecast (prediction) sensitivity vectors (column wise)
      :rtype: `pyemu.Matrix`


   .. method:: pst(self)
      :property:

      the pst attribute

      :returns: the pst attribute
      :rtype: `pyemu.Pst`


   .. method:: fehalf(self)
      :property:

      Karhunen-Loeve scaling matrix attribute.

      :returns: the Karhunen-Loeve scaling matrix based on the prior
                parameter covariance matrix
      :rtype: `pyemu.Matrix`


   .. method:: qhalf(self)
      :property:

      square root of the cofactor matrix attribute. Create the attribute if
      it has not yet been created

      :returns: square root of the cofactor matrix
      :rtype: `pyemu.Matrix`


   .. method:: qhalfx(self)
      :property:

      half normal matrix attribute.

      :returns: half normal matrix attribute
      :rtype: `pyemu.Matrix`


   .. method:: xtqx(self)
      :property:

      normal matrix attribute.

      :returns: normal matrix attribute
      :rtype: `pyemu.Matrix`


   .. method:: mle_covariance(self)
      :property:

      maximum likelihood parameter covariance matrix.

      :returns: maximum likelihood parameter covariance matrix
      :rtype: `pyemu.Matrix`


   .. method:: prior_parameter(self)
      :property:

      prior parameter covariance matrix

      :returns: prior parameter covariance matrix
      :rtype: `pyemu.Cov`


   .. method:: prior_forecast(self)
      :property:

      prior forecast (e.g. prediction) variances

      :returns: a dictionary of forecast name, prior variance pairs
      :rtype: `dict`


   .. method:: mle_parameter_estimate(self)
      :property:

      maximum likelihood parameter estimate.

      :returns: the maximum likelihood parameter estimates
      :rtype: `pandas.Series`


   .. method:: prior_prediction(self)
      :property:

      prior prediction (e.g. forecast) variances

      :returns: a dictionary of prediction name, prior variance pairs
      :rtype: `dict`


   .. method:: apply_karhunen_loeve_scaling(self)

      apply karhuene-loeve scaling to the jacobian matrix.

      .. note::

         This scaling is not necessary for analyses using Schur's
         complement, but can be very important for error variance
         analyses.  This operation effectively transfers prior knowledge
         specified in the parcov to the jacobian and reset parcov to the
         identity matrix.


   .. method:: clean(self)

      drop regularization and prior information observation from the jco


   .. method:: reset_pst(self, arg)

      reset the LinearAnalysis.pst attribute

      :param arg: the value to assign to the pst attribute
      :type arg: `str` or `pyemu.Pst`


   .. method:: reset_parcov(self, arg=None)

      reset the parcov attribute to None

      :param arg: the value to assign to the parcov
                  attribute.  If None, the private __parcov attribute is cleared
                  but not reset
      :type arg: `str` or `pyemu.Matrix`


   .. method:: reset_obscov(self, arg=None)

      reset the obscov attribute to None

      :param arg: the value to assign to the obscov
                  attribute.  If None, the private __obscov attribute is cleared
                  but not reset
      :type arg: `str` or `pyemu.Matrix`


   .. method:: drop_prior_information(self)

      drop the prior information from the jco and pst attributes


   .. method:: get(self, par_names=None, obs_names=None, astype=None)

      method to get a new LinearAnalysis class using a
      subset of parameters and/or observations

      :param par_names: par names for new object
      :type par_names: [`'str`]
      :param obs_names: obs names for new object
      :type obs_names: [`'str`]
      :param astype: type to
                     cast the new object.  If None, return type is
                     same as self
      :type astype: `pyemu.Schur` or `pyemu.ErrVar`

      :returns: new instance
      :rtype: `LinearAnalysis`


   .. method:: adjust_obscov_resfile(self, resfile=None)

      reset the elements of obscov by scaling the implied weights
      based on the phi components in res_file so that the total phi
      is equal to the number of non-zero weights.

      :param resfile: residual file to use.  If None, residual
                      file with case name is sought. default is None
      :type resfile: `str`

      .. note:: calls `pyemu.Pst.adjust_weights_resfile()`


   .. method:: get_par_css_dataframe(self)

      get a dataframe of composite scaled sensitivities.  Includes both
      PEST-style and Hill-style.

      :returns: a dataframe of parameter names, PEST-style and
                Hill-style composite scaled sensitivity
      :rtype: `pandas.DataFrame`


   .. method:: get_cso_dataframe(self)

      get a dataframe of composite observation sensitivity, as returned by PEST in the
      seo file.

      :returns: dataframe of observation names and composite observation
                sensitivity
      :rtype: `pandas.DataFrame`

      .. note::

         That this formulation deviates slightly from the PEST documentation in that the
         values are divided by (npar-1) rather than by (npar).
         
         The equation is cso_j = ((Q^1/2*J*J^T*Q^1/2)^1/2)_jj/(NPAR-1)


   .. method:: get_obs_competition_dataframe(self)

      get the observation competition stat a la PEST utility

      :returns: a dataframe of observation names by
                observation names with values equal to the PEST
                competition statistic
      :rtype: `pandas.DataFrame`



.. py:class:: Schur(jco, **kwargs)

   Bases: :class:`pyemu.la.LinearAnalysis`

   FOSM-based uncertainty and data-worth analysis

   :param jco: something that can be cast or loaded into a `pyemu.Jco`.  Can be a
               str for a filename or `pyemu.Matrix`/`pyemu.Jco` object.
   :type jco: varies, optional
   :param pst: something that can be cast into a `pyemu.Pst`.  Can be an `str` for a
               filename or an existing `pyemu.Pst`.  If `None`, a pst filename is sought
               with the same base name as the jco argument (if passed)
   :type pst: varies, optional
   :param parcov: prior parameter covariance matrix.  If `str`, a filename is assumed and
                  the prior parameter covariance matrix is loaded from a file using
                  the file extension (".jcb"/".jco" for binary, ".cov"/".mat" for PEST-style ASCII matrix,
                  or ".unc" for uncertainty files).  If `None`, the prior parameter covariance matrix is
                  constructed from the parameter bounds in `LinearAnalysis.pst`.  Can also be a `pyemu.Cov` instance
   :type parcov: varies, optional
   :param obscov: observation noise covariance matrix.  If `str`, a filename is assumed and
                  the noise covariance matrix is loaded from a file using
                  the file extension (".jcb"/".jco" for binary, ".cov"/".mat" for PEST-style ASCII matrix,
                  or ".unc" for uncertainty files).  If `None`, the noise covariance matrix is
                  constructed from the obsevation weights in `LinearAnalysis.pst`.  Can also be a `pyemu.Cov` instance
   :type obscov: varies, optional
   :param forecasts: forecast sensitivity vectors.  If `str`, first an observation name is assumed (a row
                     in `LinearAnalysis.jco`).  If that is not found, a filename is assumed and predictions are
                     loaded from a file using the file extension.  If [`str`], a list of observation names is assumed.
                     Can also be a `pyemu.Matrix` instance, a `numpy.ndarray` or a collection.  Note if the PEST++ option
                     "++forecasts()" is set in the pest control file (under the `pyemu.Pst.pestpp_options` dictionary),
                     then there is no need to pass this argument (unless you want to analyze different forecasts)
                     of `pyemu.Matrix` or `numpy.ndarray`.
   :type forecasts: varies, optional
   :param ref_var: reference variance.  Default is 1.0
   :type ref_var: float, optional
   :param verbose: controls screen output.  If `str`, a filename is assumed and
                   and log file is written.
   :type verbose: `bool`
   :param sigma_range: defines range of upper bound - lower bound in terms of standard
                       deviation (sigma). For example, if sigma_range = 4, the bounds represent 4 * sigma.
                       Default is 4.0, representing approximately 95% confidence of implied normal distribution.
                       This arg is only used if constructing parcov from parameter bounds.
   :type sigma_range: `float`, optional
   :param scale_offset: flag to apply parameter scale and offset to parameter bounds
                        when calculating prior parameter covariance matrix from bounds.  This arg is onlyused if
                        constructing parcov from parameter bounds.Default is True.
   :type scale_offset: `bool`, optional

   .. note::

      This class is the primary entry point for FOSM-based uncertainty and
      dataworth analyses
      
      This class replicates and extends the behavior of the PEST PREDUNC utilities.

   Example::

       #assumes "my.pst" exists
       sc = pyemu.Schur(jco="my.jco",forecasts=["fore1","fore2"])
       print(sc.get_forecast_summary())
       print(sc.get_parameter_contribution())

   .. method:: posterior_parameter(self)
      :property:

      posterior parameter covariance matrix.

      :returns: the posterior parameter covariance matrix
      :rtype: `pyemu.Cov`

      Example::

          sc = pyemu.Schur(jco="my.jcb")
          post_cov = sc.posterior_parameter
          post_cov.to_ascii("post.cov")


   .. method:: posterior_forecast(self)
      :property:

      posterior forecast (e.g. prediction) variance(s)

      :returns: dictionary of forecast names and FOSM-estimated posterior
                variances
      :rtype: `dict`

      .. note::

         Sames as `LinearAnalysis.posterior_prediction`
         
         See `Schur.get_forecast_summary()` for a dataframe-based container of prior and posterior
         variances


   .. method:: posterior_prediction(self)
      :property:

      posterior prediction (e.g. forecast) variance estimate(s)

      :returns: dictionary of forecast names and FOSM-estimated posterior
                variances
      :rtype: `dict`

       Note:
           sames as `LinearAnalysis.posterior_forecast`

           See `Schur.get_forecast_summary()` for a dataframe-based container of prior and posterior
           variances



   .. method:: get_parameter_summary(self)

      summary of the FOSM-based parameter uncertainty (variance) estimate(s)

      :returns: dataframe of prior,posterior variances and percent
                uncertainty reduction of each parameter
      :rtype: `pandas.DataFrame`

      .. note::

         This is the primary entry point for accessing parameter uncertainty estimates
         
         The "Prior" column in dataframe is the diagonal of `LinearAnalysis.parcov`
         "precent_reduction" column in dataframe is calculated as 100.0 * (1.0 -
         (posterior variance / prior variance)

      Example::

          sc = pyemu.Schur(jco="my.jcb",forecasts=["fore1","fore2"])
          df = sc.get_parameter_summary()
          df.loc[:,["prior","posterior"]].plot(kind="bar")
          plt.show()
          df.percent_reduction.plot(kind="bar")
          plt.show()


   .. method:: get_forecast_summary(self)

      summary of the FOSM-based forecast uncertainty (variance) estimate(s)

      :returns: dataframe of prior,posterior variances and percent
                uncertainty reduction of each forecast (e.g. prediction)
      :rtype: `pandas.DataFrame`

      .. note::

         This is the primary entry point for accessing forecast uncertainty estimates
         "precent_reduction" column in dataframe is calculated as
         100.0 * (1.0 - (posterior variance / prior variance)

      Example::

          sc = pyemu.Schur(jco="my.jcb",forecasts=["fore1","fore2"])
          df = sc.get_parameter_summary()
          df.loc[:,["prior","posterior"]].plot(kind="bar")
          plt.show()
          df.percent_reduction.plot(kind="bar")
          plt.show()


   .. method:: __contribution_from_parameters(self, parameter_names)

      private method get the prior and posterior uncertainty reduction as a result of
      some parameter becoming perfectly known


   .. method:: get_conditional_instance(self, parameter_names)

      get a new `pyemu.Schur` instance that includes conditional update from
      some parameters becoming known perfectly

      :param parameter_names: list of parameters that are to be treated as
                              notionally perfectly known
      :type parameter_names: [`str`]

      :returns: a new Schur instance conditional on perfect knowledge
                of some parameters. The new instance has an updated `parcov` that is less
                the names listed in `parameter_names`.
      :rtype: `pyemu.Schur`

      .. note::

         This method is primarily for use by the `LinearAnalysis.get_parameter_contribution()`
         dataworth method.


   .. method:: get_par_contribution(self, parlist_dict=None, include_prior_results=False)

      A dataworth method to get a dataframe the prior and posterior uncertainty
      reduction as a result of some parameter becoming perfectly known

      :param parlist_dict: (`dict`, optional): a nested dictionary-list of groups of parameters
                           that are to be treated as perfectly known.  key values become
                           row labels in returned dataframe.  If `None`, each adjustable parameter
                           is sequentially treated as known and the returned dataframe
                           has row labels for each adjustable parameter
      :param include_prior_results: flag to return a multi-indexed dataframe with both conditional
                                    prior and posterior forecast uncertainty estimates.  This is because
                                    the notional learning about parameters potentially effects both the prior
                                    and posterior forecast uncertainty estimates. If `False`, only posterior
                                    results are returned.  Default is `False`
      :type include_prior_results: `bool`, optional

      :returns: a dataframe that summarizes the parameter contribution
                dataworth analysis. The dataframe has index (row labels) of the keys in parlist_dict
                and a column labels of forecast names.  The values in the dataframe
                are the posterior variance of the forecast conditional on perfect
                knowledge of the parameters in the values of parlist_dict.  One row in the
                dataframe will be labeled `base` - this is the forecast uncertainty estimates
                that include the effects of all adjustable parameters.  Percent decreases in
                forecast uncertainty can be calculated by differencing all rows against the
                "base" row.  Varies depending on `include_prior_results`.
      :rtype: `pandas.DataFrame`

      .. note::

         This is the primary dataworth method for assessing the contribution of one or more
         parameters to forecast uncertainty.

      Example::

          sc = pyemu.Schur(jco="my.jco")
          parlist_dict = {"hk":["hk1","hk2"],"rech"["rech1","rech2"]}
          df = sc.get_par_contribution(parlist_dict=parlist_dict)



   .. method:: get_par_group_contribution(self, include_prior_results=False)

      A dataworth method to get the forecast uncertainty contribution from each parameter
      group

      :param include_prior_results: flag to return a multi-indexed dataframe with both conditional
                                    prior and posterior forecast uncertainty estimates.  This is because
                                    the notional learning about parameters potentially effects both the prior
                                    and posterior forecast uncertainty estimates. If `False`, only posterior
                                    results are returned.  Default is `False`
      :type include_prior_results: `bool`, optional

      :returns: a dataframe that summarizes the parameter contribution analysis.
                The dataframe has index (row labels) that are the parameter group names
                and a column labels of forecast names.  The values in the dataframe
                are the posterior variance of the forecast conditional on perfect
                knowledge of the adjustable parameters in each parameter group.  One
                row is labelled "base" - this is the variance of the forecasts that includes
                the effects of all adjustable parameters. Varies depending on `include_prior_results`.
      :rtype: `pandas.DataFrame`

      .. note::

         This method is just a thin wrapper around get_contribution_dataframe() - this method
         automatically constructs the parlist_dict argument where the keys are the
         group names and the values are the adjustable parameters in the groups

      Example::

          sc = pyemu.Schur(jco="my.jco")
          df = sc.get_par_group_contribution()




   .. method:: get_added_obs_importance(self, obslist_dict=None, base_obslist=None, reset_zero_weight=False)

      A dataworth method to analyze the posterior uncertainty as a result of gathering
       some additional observations

      :param obslist_dict: a nested dictionary-list of groups of observations
                           that are to be treated as gained/collected.  key values become
                           row labels in returned dataframe. If `None`, then every zero-weighted
                           observation is tested sequentially. Default is `None`
      :type obslist_dict: `dict`, optional
      :param base_obslist: observation names to treat as the "existing" observations.
                           The values of `obslist_dict` will be added to this list during
                           each test.  If `None`, then the values in each `obslist_dict` entry will
                           be treated as the entire calibration dataset.  That is, there
                           are no existing observations. Default is `None`.  Standard practice would
                           be to pass this argument as `pyemu.Schur.pst.nnz_obs_names` so that existing,
                           non-zero-weighted observations are accounted for in evaluating the worth of
                           new yet-to-be-collected observations.
      :type base_obslist: [`str`], optional
      :param reset_zero_weight: a flag to reset observations with zero weight in either
                                `obslist_dict` or `base_obslist`. If `reset_zero_weights`
                                passed as a `float`,then that value will be assigned to
                                zero weight obs.  Otherwise, zero-weight obs will be given a
                                weight of 1.0.  Default is `False`.
      :type reset_zero_weight: `bool`, optional

      :returns: a dataframe with row labels (index) of `obslist_dict.keys()` and
                columns of forecast names.  The values in the dataframe are the
                posterior variance of the forecasts resulting from notional inversion
                using the observations in `obslist_dict[key value]` plus the observations
                in `base_obslist` (if any).  One row in the dataframe is labeled "base" - this is
                posterior forecast variance resulting from the notional calibration with the
                observations in `base_obslist` (if `base_obslist` is `None`, then the "base" row is the
                prior forecast variance).  Conceptually, the forecast variance should either not change or
                decrease as a result of gaining additional observations.  The magnitude of the decrease
                represents the worth of the potential new observation(s) being tested.
      :rtype: `pandas.DataFrame`

      .. note::

         Observations listed in `obslist_dict` and `base_obslist` with zero
         weights are not included in the analysis unless `reset_zero_weight` is `True` or a float
         greater than zero.  In most cases, users will want to reset zero-weighted observations as part
         dataworth testing process.

      Example::

          sc = pyemu.Schur("my.jco")
          obslist_dict = {"hds":["head1","head2"],"flux":["flux1","flux2"]}
          df = sc.get_added_obs_importance(obslist_dict=obslist_dict,
                                           base_obslist=sc.pst.nnz_obs_names,
                                           reset_zero_weight=True)


   .. method:: get_removed_obs_importance(self, obslist_dict=None, reset_zero_weight=False)

      A dataworth method to analyze the posterior uncertainty as a result of losing
       some existing observations

      :param obslist_dict: a nested dictionary-list of groups of observations
                           that are to be treated as lost.  key values become
                           row labels in returned dataframe. If `None`, then every zero-weighted
                           observation is tested sequentially. Default is `None`
      :type obslist_dict: `dict`, optional
      :param reset_zero_weight: a flag to reset observations with zero weight in either
                                `obslist_dict` or `base_obslist`. If `reset_zero_weights`
                                passed as a `float`,then that value will be assigned to
                                zero weight obs.  Otherwise, zero-weight obs will be given a
                                weight of 1.0.  Default is `False`.
      :type reset_zero_weight: `bool`, optional

      :returns: A dataframe with index of obslist_dict.keys() and columns
                of forecast names.  The values in the dataframe are the posterior
                variances of the forecasts resulting from losing the information
                contained in obslist_dict[key value]. One row in the dataframe is labeled "base" - this is
                posterior forecast variance resulting from the notional calibration with the
                non-zero-weighed observations in `Schur.pst`.  Conceptually, the forecast variance should
                either not change or increase as a result of losing existing observations.  The magnitude
                of the increase represents the worth of the existing observation(s) being tested.
      :rtype: `pandas.DataFrame`

      .. note::

         Observations listed in `obslist_dict` and `base_obslist` with zero
         weights are not included in the analysis unless `reset_zero_weight` is `True` or a float
         greater than zero.  In most cases, users will want to reset zero-weighted observations as part
         dataworth testing process.

      Example::

          sc = pyemu.Schur("my.jco")
          df = sc.get_removed_obs_importance(reset_zero_weight=True)


   .. method:: get_obs_group_dict(self)

      get a dictionary of observations grouped by observation group name

      :returns: a dictionary of observations grouped by observation group name.
                Useful for dataworth processing in `pyemu.Schur`
      :rtype: `dict`

      .. note:: only includes observations that are listed in `Schur.jco.row_names`

      Example::

          sc = pyemu.Schur("my.jco")
          obsgrp_dict = sc.get_obs_group_dict()
          df = sc.get_removed_obs_importance(obsgrp_dict=obsgrp_dict, reset_zero_weight=True)


   .. method:: get_removed_obs_group_importance(self, reset_zero_weight=False)

      A dataworth method to analyze the posterior uncertainty as a result of losing
       existing observations, tested by observation groups

      :param reset_zero_weight: a flag to reset observations with zero weight in either
                                `obslist_dict` or `base_obslist`. If `reset_zero_weights`
                                passed as a `float`,then that value will be assigned to
                                zero weight obs.  Otherwise, zero-weight obs will be given a
                                weight of 1.0.  Default is `False`.
      :type reset_zero_weight: `bool`, optional

      :returns: A dataframe with index of observation group names and columns
                of forecast names.  The values in the dataframe are the posterior
                variances of the forecasts resulting from losing the information
                contained in each observation group. One row in the dataframe is labeled "base" - this is
                posterior forecast variance resulting from the notional calibration with the
                non-zero-weighed observations in `Schur.pst`.  Conceptually, the forecast variance should
                either not change or increase as a result of losing existing observations.  The magnitude
                of the increase represents the worth of the existing observation(s) in each group being tested.
      :rtype: `pandas.DataFrame`

      .. note::

         Observations in `Schur.pst` with zero weights are not included in the analysis unless
         `reset_zero_weight` is `True` or a float greater than zero.  In most cases, users
         will want to reset zero-weighted observations as part dataworth testing process.

      Example::

          sc = pyemu.Schur("my.jco")
          df = sc.get_removed_obs_group_importance(reset_zero_weight=True)


   .. method:: get_added_obs_group_importance(self, reset_zero_weight=False)

      A dataworth method to analyze the posterior uncertainty as a result of gaining
       existing observations, tested by observation groups

      :param reset_zero_weight: a flag to reset observations with zero weight in either
                                `obslist_dict` or `base_obslist`. If `reset_zero_weights`
                                passed as a `float`,then that value will be assigned to
                                zero weight obs.  Otherwise, zero-weight obs will be given a
                                weight of 1.0.  Default is `False`.
      :type reset_zero_weight: `bool`, optional

      :returns: A dataframe with index of observation group names and columns
                of forecast names.  The values in the dataframe are the posterior
                variances of the forecasts resulting from gaining the information
                contained in each observation group. One row in the dataframe is labeled "base" - this is
                posterior forecast variance resulting from the notional calibration with the
                non-zero-weighed observations in `Schur.pst`.  Conceptually, the forecast variance should
                either not change or decrease as a result of gaining new observations.  The magnitude
                of the decrease represents the worth of the potential new observation(s) in each group
                being tested.
      :rtype: `pandas.DataFrame`

      .. note::

         Observations in `Schur.pst` with zero weights are not included in the analysis unless
         `reset_zero_weight` is `True` or a float greater than zero.  In most cases, users
         will want to reset zero-weighted observations as part dataworth testing process.

      Example::

          sc = pyemu.Schur("my.jco")
          df = sc.get_added_obs_group_importance(reset_zero_weight=True)


   .. method:: next_most_important_added_obs(self, forecast=None, niter=3, obslist_dict=None, base_obslist=None, reset_zero_weight=False)

      find the most important observation(s) by sequentially evaluating
      the importance of the observations in `obslist_dict`.

      :param forecast: name of the forecast to use in the ranking process.  If
                       more than one forecast has been listed, this argument is required.  This is because
                       the data worth must be ranked with respect to the variance reduction for a single
                       forecast
      :type forecast: `str`, optional
      :param niter: number of sequential dataworth testing iterations.  Default is 3
      :type niter: `int`, optional
      :param obslist_dict: a nested dictionary-list of groups of observations
                           that are to be treated as gained/collected.  key values become
                           row labels in returned dataframe. If `None`, then every zero-weighted
                           observation is tested sequentially. Default is `None`
      :type obslist_dict: `dict`, optional
      :param base_obslist: observation names to treat as the "existing" observations.
                           The values of `obslist_dict` will be added to this list during
                           each test.  If `None`, then the values in each `obslist_dict` entry will
                           be treated as the entire calibration dataset.  That is, there
                           are no existing observations. Default is `None`.  Standard practice would
                           be to pass this argument as `pyemu.Schur.pst.nnz_obs_names` so that existing,
                           non-zero-weighted observations are accounted for in evaluating the worth of
                           new yet-to-be-collected observations.
      :type base_obslist: [`str`], optional
      :param reset_zero_weight: a flag to reset observations with zero weight in either
                                `obslist_dict` or `base_obslist`. If `reset_zero_weights`
                                passed as a `float`,then that value will be assigned to
                                zero weight obs.  Otherwise, zero-weight obs will be given a
                                weight of 1.0.  Default is `False`.
      :type reset_zero_weight: `bool`, optional

      :returns: a dataFrame with columns of `obslist_dict` key for each iteration
                the yields the largest variance reduction for the named `forecast`. Columns are forecast
                variance percent reduction for each iteration (percent reduction compared to initial "base"
                case with all non-zero weighted observations included in the notional calibration)
      :rtype: `pandas.DataFrame`

      .. note::

         The most important observations from each iteration is added to `base_obslist`
         and removed `obslist_dict` for the next iteration.  In this way, the added
         observation importance values include the conditional information from
         the last iteration.

      Example::

          sc = pyemu.Schur(jco="my.jco")
          df = sc.next_most_important_added_obs(forecast="fore1",base_obslist=sc.pst.nnz_obs_names)


   .. method:: next_most_par_contribution(self, niter=3, forecast=None, parlist_dict=None)

      find the parameter(s) contributing most to posterior
      forecast  by sequentially evaluating the contribution of parameters in
      `parlist_dict`.

      :param forecast: name of the forecast to use in the ranking process.  If
                       more than one forecast has been listed, this argument is required.  This is because
                       the data worth must be ranked with respect to the variance reduction for a single
                       forecast
      :type forecast: `str`, optional
      :param niter: number of sequential dataworth testing iterations.  Default is 3
      :type niter: `int`, optional
      :param parlist_dict: dict
                           a nested dictionary-list of groups of parameters
                           that are to be treated as perfectly known.  key values become
                           row labels in dataframe
      :param parlist_dict: a nested dictionary-list of groups of parameters
                           that are to be treated as perfectly known (zero uncertainty).  key values become
                           row labels in returned dataframe. If `None`, then every adustable parameter is tested
                           sequentially. Default is `None`. Conceptually, the forecast variance should
                           either not change or decrease as a result of knowing parameter perfectly.  The magnitude
                           of the decrease represents the worth of gathering information about the parameter(s) being
                           tested.
      :type parlist_dict: `dict`, optional

      .. note::

         The largest contributing parameters from each iteration are
         treated as known perfectly for the remaining iterations.  In this way, the
         next iteration seeks the next most influential group of parameters.

      :returns: a dataframe with index of iteration number and columns
                of `parlist_dict.keys()`.  The values are the results of the knowing
                each parlist_dict entry expressed as posterior variance reduction
      :rtype: `pandas.DataFrame`



.. py:class:: ErrVar(jco, **kwargs)

   Bases: :class:`pyemu.la.LinearAnalysis`

   FOSM-based error variance analysis

   :param jco: something that can be cast or loaded into a `pyemu.Jco`.  Can be a
               str for a filename or `pyemu.Matrix`/`pyemu.Jco` object.
   :type jco: varies, optional
   :param pst: something that can be cast into a `pyemu.Pst`.  Can be an `str` for a
               filename or an existing `pyemu.Pst`.  If `None`, a pst filename is sought
               with the same base name as the jco argument (if passed)
   :type pst: varies, optional
   :param parcov: prior parameter covariance matrix.  If `str`, a filename is assumed and
                  the prior parameter covariance matrix is loaded from a file using
                  the file extension (".jcb"/".jco" for binary, ".cov"/".mat" for PEST-style ASCII matrix,
                  or ".unc" for uncertainty files).  If `None`, the prior parameter covariance matrix is
                  constructed from the parameter bounds in `LinearAnalysis.pst`.  Can also be a `pyemu.Cov` instance
   :type parcov: varies, optional
   :param obscov: observation noise covariance matrix.  If `str`, a filename is assumed and
                  the noise covariance matrix is loaded from a file using
                  the file extension (".jcb"/".jco" for binary, ".cov"/".mat" for PEST-style ASCII matrix,
                  or ".unc" for uncertainty files).  If `None`, the noise covariance matrix is
                  constructed from the obsevation weights in `LinearAnalysis.pst`.  Can also be a `pyemu.Cov` instance
   :type obscov: varies, optional
   :param forecasts: forecast sensitivity vectors.  If `str`, first an observation name is assumed (a row
                     in `LinearAnalysis.jco`).  If that is not found, a filename is assumed and predictions are
                     loaded from a file using the file extension.  If [`str`], a list of observation names is assumed.
                     Can also be a `pyemu.Matrix` instance, a `numpy.ndarray` or a collection.  Note if the PEST++ option
                     "++forecasts()" is set in the pest control file (under the `pyemu.Pst.pestpp_options` dictionary),
                     then there is no need to pass this argument (unless you want to analyze different forecasts)
                     of `pyemu.Matrix` or `numpy.ndarray`.
   :type forecasts: varies, optional
   :param ref_var: reference variance.  Default is 1.0
   :type ref_var: float, optional
   :param verbose: controls screen output.  If `str`, a filename is assumed and
                   and log file is written.
   :type verbose: `bool`
   :param sigma_range: defines range of upper bound - lower bound in terms of standard
                       deviation (sigma). For example, if sigma_range = 4, the bounds represent 4 * sigma.
                       Default is 4.0, representing approximately 95% confidence of implied normal distribution.
                       This arg is only used if constructing parcov from parameter bounds.
   :type sigma_range: `float`, optional
   :param scale_offset: flag to apply parameter scale and offset to parameter bounds
                        when calculating prior parameter covariance matrix from bounds.  This arg is onlyused if
                        constructing parcov from parameter bounds.Default is True.
   :type scale_offset: `bool`, optional
   :param omitted_parameters: list of parameters to treat as "omitted".  Passing this argument
                              activates 3-term error variance analysis.
   :type omitted_parameters: [`str`]
   :param omitted_parcov: an argument that can be cast to a parcov for the omitted parameters.
                          If None, omitted_parcov will be formed by extracting a sub-matrix from the `LinearAnalsis.parcov`
                          attribute.
   :type omitted_parcov: varies
   :param omitted_predictions: an argument that can be cast to a "predictions" (e.g. "forecasts")
                               attribute to form prediction sensitivity vectors with respec to the omitted parameters.  If None,
                               these vectors will be extracted from the `pyemu.LinearAnalysis.predictions` attribute
   :type omitted_predictions: varies
   :param kl: flag to perform Karhunen-Loeve scaling on the jacobian before error variance
              calculations. If `True`, the `pyemu.ErrVar.jco` and `pyemu.ErrVar.parcov` are altered in place.
              Default is `False`.
   :type kl: `bool`, optional

   Example::

       ev = pyemu.ErrVar(jco="my.jco",omitted_parameters=["wel1","wel2"])
       df = ev.get_errvar_dataframe()

   .. method:: __load_omitted_predictions(self)

      private: set the omitted_predictions attribute


   .. method:: __load_omitted_parcov(self)

      private: set the omitted_parcov attribute


   .. method:: __load_omitted_jco(self)

      private: set the omitted jco attribute


   .. method:: omitted_predictions(self)
      :property:

      omitted prediction sensitivity vectors

      :returns: a matrix of prediction sensitivity vectors (column wise) to
                omitted parameters
      :rtype: `pyemu.Matrix`


   .. method:: omitted_jco(self)
      :property:

      the omitted-parameters jacobian matrix

      :returns: the jacobian matrix instance of non-zero-weighted observations and
                omitted parameters
      :rtype: `pyemu.Jco`


   .. method:: omitted_parcov(self)
      :property:

      the prior omitted-parameter covariance matrix

      :returns: the prior parameter covariance matrix of the
                omitted parameters
      :rtype: `pyemu.Cov`


   .. method:: get_errvar_dataframe(self, singular_values=None)

      primary entry point for error variance analysis.

      :param singular_values: a list singular values to test. If `None`,
                              defaults to `range(0,min(nnz_obs,nadj_par) + 1)`.
      :type singular_values: [`int`], optional

      :returns: a multi-indexed pandas dataframe summarizing each of the
                error variance terms for each nominated forecast. Rows are the singluar values
                tested, columns are a multi-index of forecast name and error variance term number
                (e.g. 1,2 or (optionally) 3).
      :rtype: `pandas.DataFrame`

      Example::

          ev = pyemu.ErrVar(jco="my.jco",omitted_parameters=["wel1","wel2"])
          df = ev.get_errvar_dataframe()


   .. method:: get_identifiability_dataframe(self, singular_value=None, precondition=False)

      primary entry point for identifiability analysis

      :param singular_value: the singular spectrum truncation point. Defaults
                             to minimum of non-zero-weighted observations and adjustable parameters
      :type singular_value: `int`
      :param precondition: flag to use the preconditioned hessian with the prior
                           parameter covariance matrix (xtqt + sigma_theta^-1).  This should be used
                           KL scaling. Default is `False`.
      :type precondition: `bool`

      :returns: A pandas dataframe of the right solution-space singular
                vectors and identifiability (identifiabiity is in the column labeled "ident")
      :rtype: `pandas.DataFrame`

      Examples::

          ev = pyemu.ErrVar(jco="my.jco")
          df = ev.get_identifiability_dataframe(singular_value=20)
          df.ident.plot(kind="bar")


   .. method:: variance_at(self, singular_value)

      get the error variance of all three error variance terms at a
       given singluar value

      :param singular_value: singular value to test
      :type singular_value: `int`

      :returns: dictionary of (err var term,prediction_name), variance pairs
      :rtype: `dict`


   .. method:: R(self, singular_value)

      get resolution Matrix (V_1 * V_1^T) at a given singular value

      Args:
      singular_value (`int`): singular value to calculate `R` at

      :returns: resolution matrix at `singular_value`
      :rtype: `pyemu.Matrix`


   .. method:: I_minus_R(self, singular_value)

      get I - R at a given singular value

      :param singular_value: singular value to calculate I - R at
      :type singular_value: `int`

      :returns: identity matrix minus resolution matrix at `singular_value`
      :rtype: `pyemu.Matrix`


   .. method:: G(self, singular_value)

      get the parameter solution Matrix at a given singular value

      :param singular_value: singular value to calc G at
      :type singular_value: `int`

      :returns: parameter solution matrix  (V_1 * S_1^(_1) * U_1^T) at `singular_value`
      :rtype: `pyemu.Matrix`


   .. method:: first_forecast(self, singular_value)

      get the null space term (first term) contribution to forecast (e.g. prediction)
       error variance at a given singular value.

      :param singular_value: singular value to calc first term at
      :type singular_value: `int`

      .. note::

         This method is used to construct the error variance dataframe
         
         Just a wrapper around `ErrVar.first_forecast`

      :returns: dictionary of ("first",prediction_names),error variance pairs at `singular_value`
      :rtype: `dict`


   .. method:: first_prediction(self, singular_value)

      get the null space term (first term) contribution to prediction error variance
          at a given singular value.

      :param singular_value: singular value to calc first term at
      :type singular_value: `int`

      .. note:: This method is used to construct the error variance dataframe

      :returns: dictionary of ("first",prediction_names),error variance pairs at `singular_value`
      :rtype: `dict`


   .. method:: first_parameter(self, singular_value)

      get the null space term (first term) contribution to parameter error variance
          at a given singular value

      :param singular_value: singular value to calc first term at
      :type singular_value: `int`

      :returns: first term contribution to parameter error variance
      :rtype: `pyemu.Cov`


   .. method:: second_forecast(self, singular_value)

      get the solution space contribution to forecast (e.g. "prediction") error variance
      at a given singular value

      :param singular_value: singular value to calc second term at
      :type singular_value: `int`

      .. note::

         This method is used to construct error variance dataframe
         
         Just a thin wrapper around `ErrVar.second_prediction`

      :returns: dictionary of ("second",prediction_names), error variance
                arising from the solution space contribution (y^t * G * obscov * G^T * y)
      :rtype: `dict`


   .. method:: second_prediction(self, singular_value)

      get the solution space contribution to predictive error variance
      at a given singular value

      :param singular_value: singular value to calc second term at
      :type singular_value: `int`

      .. note:: This method is used to construct error variance dataframe

      Returns:            `dict`:  dictionary of ("second",prediction_names), error variance
          arising from the solution space contribution (y^t * G * obscov * G^T * y)


   .. method:: second_parameter(self, singular_value)

      get the solution space contribution to parameter error variance
           at a given singular value (G * obscov * G^T)

      :param singular_value: singular value to calc second term at
      :type singular_value: `int`

      :returns: the second term contribution to parameter error variance
                (G * obscov * G^T)
      :rtype: `pyemu.Cov`


   .. method:: third_forecast(self, singular_value)

      get the omitted parameter contribution to forecast (`prediction`) error variance
       at a given singular value.

      :param singular_value: singular value to calc third term at
      :type singular_value: `int`

      .. note::

         used to construct error variance dataframe
         just a thin wrapper around `ErrVar.third_prediction()`

      :returns: a dictionary of ("third",prediction_names),error variance
      :rtype: `dict`


   .. method:: third_prediction(self, singular_value)

      get the omitted parameter contribution to prediction error variance
       at a given singular value.

      :param singular_value: singular value to calc third term at
      :type singular_value: `int`

      .. note:: used to construct error variance dataframe

      :returns: a dictionary of ("third",prediction_names),error variance
      :rtype: `dict`


   .. method:: third_parameter(self, singular_value)

      get the omitted parameter contribution to parameter error variance
           at a given singular value

      :param singular_value: singular value to calc third term at
      :type singular_value: `int`

      :returns: the third term contribution to parameter error variance
                calculated at `singular_value` (G * omitted_jco * Sigma_(omitted_pars) *
                omitted_jco^T * G^T).  Returns 0.0 if third term calculations are not
                being used.
      :rtype: `pyemu.Cov`


   .. method:: get_null_proj(self, maxsing=None, eigthresh=1e-06)

      get a null-space projection matrix of XTQX

      :param maxsing: number of singular components
                      to use (the truncation point).  If None, `pyemu.Matrx.get_maxsing()
                      is used to determine the truncation point with `eigthresh`. Default
                      is None
      :type maxsing: `int`, optional
      :param eigthresh: the ratio of smallest to largest singular
                        value to keep in the range (solution) space of XtQX.  Not used if
                        `maxsing` is not `None`.  Default is 1.0e-6
      :type eigthresh: `float`, optional

      .. note:: used for null-space monte carlo operations.

      :returns: `pyemu.Matrix` the null-space projection matrix (V2V2^T)



.. py:class:: Ensemble(pst, df, istransformed=False)

   Bases: :class:`object`

   based class for handling ensembles of numeric values

   :param pst: a control file instance
   :type pst: `pyemu.Pst`
   :param df: a pandas dataframe.  Columns
              should be parameter/observation names.  Index is
              treated as realization names
   :type df: `pandas.DataFrame`
   :param istransformed: flag to indicate parameter values
                         are in log space.  Not used for `ObservationEnsemble`
   :type istransformed: `bool`

   Example::

       pst = pyemu.Pst("my.pst")
       pe = pyemu.ParameterEnsemble.from_gaussian_draw(pst)

   .. attribute:: _df
      

      the underlying dataframe that stores the realized values

      :type: `pandas.DataFrame`


   .. attribute:: pst
      

      control file instance

      :type: `pyemu.Pst`


   .. method:: __repr__(self)

      Return repr(self).


   .. method:: __str__(self)

      Return str(self).


   .. method:: __sub__(self, other)


   .. method:: __mul__(self, other)


   .. method:: __truediv__(self, other)


   .. method:: __add__(self, other)


   .. method:: __pow__(self, pow)


   .. method:: reseed()
      :staticmethod:

      reset the `numpy.random.seed`

      .. note:: reseeds using the pyemu.en.SEED global variable


   .. method:: copy(self)

      get a copy of `Ensemble`

      :returns: copy of this `Ensemble`
      :rtype: `Ensemble`

      .. note:: copies both `Ensemble.pst` and `Ensemble._df`


   .. method:: istransformed(self)
      :property:

      the parameter transformation status

      :returns: flag to indicate whether or not the `ParameterEnsemble` is
                transformed with respect to log_{10}.  Not used for (and has no effect
                on) `ObservationEnsemble`.
      :rtype: `bool`

      .. note::

         parameter transformation status is only related to log_{10} and does not
         include the effects of `scale` and/or `offset`


   .. method:: transform(self)

      transform parameters with respect to `partrans` value.

      .. note::

         operates in place (None is returned).
         
         Parameter transform is only related to log_{10} and does not
         include the effects of `scale` and/or `offset`
         
         `Ensemble.transform() is only provided for inhertance purposes.
         It only changes the `Ensemble._transformed` flag


   .. method:: back_transform(self)

      back transform parameters with respect to `partrans` value.

      .. note::

         operates in place (None is returned).
         
         Parameter transform is only related to log_{10} and does not
         include the effects of `scale` and/or `offset`
         
         `Ensemble.back_transform() is only provided for inhertance purposes.
         It only changes the `Ensemble._transformed` flag


   .. method:: __getattr__(self, item)


   .. method:: plot(self, bins=10, facecolor='0.5', plot_cols=None, filename='ensemble.pdf', func_dict=None, **kwargs)

      plot ensemble histograms to multipage pdf

      :param bins: number of bins for the histograms
      :type bins: `int`
      :param facecolor: matplotlib color (e.g. `r`,`g`, etc)
      :type facecolor: `str`
      :param plot_cols: list of subset of ensemble columns to plot.
                        If None, all are plotted. Default is None
      :type plot_cols: [`str`]
      :param filename: multipage pdf filename. Default is "ensemble.pdf"
      :type filename: `str`
      :param func_dict: a dict of functions to apply to specific
                        columns. For example: {"par1": np.log10}
      :type func_dict: `dict`
      :param \*\*kwargs: addkeyword args to pass to `pyemu.plot_utils.ensemble_helper()`
      :type \*\*kwargs: `dict`

      Example::

          pst = pyemu.Pst("my.pst")
          pe = pyemu.ParameterEnsemble.from_gaussian_draw(pst)
          pe.transform() # plot log space (if needed)
          pe.plot(bins=30)


   .. method:: from_binary(cls, pst, filename)
      :classmethod:

      create an `Ensemble` from a PEST-style binary file

      :param pst: a control file instance
      :type pst: `pyemu.Pst`
      :param filename: filename containing binary ensemble
      :type filename: `str`

      :returns: the ensembled loaded from the binary file
      :rtype: `Ensemble`

      Example::

          pst = pyemu.Pst("my.pst")
          oe = pyemu.ObservationEnsemble.from_binary("obs.jcb")



   .. method:: from_csv(cls, pst, filename, *args, **kwargs)
      :classmethod:

      create an `Ensemble` from a CSV file

      :param pst: a control file instance
      :type pst: `pyemu.Pst`
      :param filename: filename containing CSV ensemble
      :type filename: `str`
      :param \*args ([`object`]: positional arguments to pass to
                                 `pandas.read_csv()`.
      :param \*\*kwargs ({`str`: `object`}): keyword arguments to pass
                                 to `pandas.read_csv()`.

      :returns: `Ensemble`

      .. note::

         uses `pandas.read_csv()` to load numeric values from
         CSV file

      Example::

          pst = pyemu.Pst("my.pst")
          oe = pyemu.ObservationEnsemble.from_csv("obs.csv")


   .. method:: to_csv(self, filename, *args, **kwargs)

      write `Ensemble` to a CSV file

      :param filename: file to write
      :type filename: `str`
      :param \*args ([`object`]: positional arguments to pass to
                                 `pandas.DataFrame.to_csv()`.
      :param \*\*kwargs ({`str`: `object`}): keyword arguments to pass
                                 to `pandas.DataFrame.to_csv()`.

      Example::

          pst = pyemu.Pst("my.pst")
          oe = pyemu.ObservationEnsemble.from_gaussian_draw(pst)
          oe.to_csv("obs.csv")

      .. note::

         back transforms `ParameterEnsemble` before writing so that
         values are in arithmatic space


   .. method:: to_binary(self, filename)

      write `Ensemble` to a PEST-style binary file

      :param filename: file to write
      :type filename: `str`

      Example::

          pst = pyemu.Pst("my.pst")
          oe = pyemu.ObservationEnsemble.from_gaussian_draw(pst)
          oe.to_binary("obs.csv")

      .. note::

         back transforms `ParameterEnsemble` before writing so that
         values are in arithmatic space


   .. method:: from_dataframe(cls, pst, df, istransformed=False)
      :classmethod:


   .. method:: _gaussian_draw(cov, mean_values, num_reals, grouper=None, fill=True, factor='eigen')
      :staticmethod:


   .. method:: _get_svd_projection_matrix(x, maxsing=None, eigthresh=1e-07)
      :staticmethod:


   .. method:: _get_eigen_projection_matrix(x)
      :staticmethod:


   .. method:: get_deviations(self, center_on=None)

      get the deviations of the realizations around a certain
      point in ensemble space

      :param center_on: a realization name to use as the centering
                        point in ensemble space.  If `None`, the mean vector is
                        treated as the centering point.  Default is None
      :type center_on: `str`, optional

      :returns: an ensemble of deviations around the centering point
      :rtype: `Ensemble`

      .. note::

         deviations are the Euclidean distances from the `center_on` value to
         realized values for each column
         
         `center_on=None` yields the classic ensemble smoother/ensemble Kalman
         filter deviations
         
         Deviations respect log-transformation status.


   .. method:: as_pyemu_matrix(self, typ=None)

      get a `pyemu.Matrix` instance of `Ensemble`

      :param typ: the type of matrix to return.
                  Default is `pyemu.Matrix`
      :type typ: `pyemu.Matrix` or `pyemu.Cov`

      :returns: a matrix instance
      :rtype: `pyemu.Matrix`

      Example::

          pst = pyemu.Pst("my.pst")
          oe = pyemu.ObservationEnsemble.from_gaussian_draw(pst)
          oe.add_base()
          oe_dev = oe.get_deviations(center_on="base")
          oe.to_csv("obs_base_devs.csv")


   .. method:: covariance_matrix(self, localizer=None, center_on=None)

      get a empirical covariance matrix implied by the
      correlations between realizations

      :param localizer: a matrix to localize covariates
                        in the resulting covariance matrix.  Default is None
      :type localizer: `pyemu.Matrix`, optional
      :param center_on: a realization name to use as the centering
                        point in ensemble space.  If `None`, the mean vector is
                        treated as the centering point.  Default is None
      :type center_on: `str`, optional

      :returns: the empirical (and optionally localized) covariance matrix
      :rtype: `pyemu.Cov`


   .. method:: dropna(self, *args, **kwargs)

      override of `pandas.DataFrame.dropna()`

      :param \*args ([`object`]: positional arguments to pass to
                                 `pandas.DataFrame.dropna()`.
      :param \*\*kwargs ({`str`: `object`}): keyword arguments to pass
                                 to `pandas.DataFrame.dropna()`.



.. py:class:: ParameterEnsemble(pst, df, istransformed=False)

   Bases: :class:`pyemu.en.Ensemble`

   Parameter ensembles in the PEST(++) realm

   :param pst: a control file instance
   :type pst: `pyemu.Pst`
   :param df: a pandas dataframe.  Columns
              should be parameter names.  Index is
              treated as realization names
   :type df: `pandas.DataFrame`
   :param istransformed: flag to indicate parameter values
                         are in log space (if `partrans` is "log" in `pst`)
   :type istransformed: `bool`

   Example::

       pst = pyemu.Pst("my.pst")
       pe = pyemu.ParameterEnsemble.from_gaussian_draw(pst)

   .. method:: from_gaussian_draw(cls, pst, cov=None, num_reals=100, by_groups=True, fill=True, factor='eigen')
      :classmethod:

      generate a `ParameterEnsemble` from a (multivariate) (log) gaussian
      distribution

      :param pst: a control file instance.
      :type pst: `pyemu.Pst`
      :param cov: a covariance matrix describing the second
                  moment of the gaussian distribution.  If None, `cov` is
                  generated from the bounds of the adjustable parameters in `pst`.
                  the (log) width of the bounds is assumed to represent a multiple of
                  the parameter standard deviation (this is the `sigma_range` argument
                  that can be passed to `pyemu.Cov.from_parameter_data`).
      :type cov: `pyemu.Cov`
      :param num_reals: number of stochastic realizations to generate.  Default
                        is 100
      :type num_reals: `int`
      :param by_groups: flag to generate realzations be parameter group.  This
                        assumes no correlation (covariates) between parameter groups.  For large
                        numbers of parameters, this help prevent memories but is slower.
      :type by_groups: `bool`
      :param fill: flag to fill in fixed and/or tied parameters with control file
                   values.  Default is True.
      :type fill: `bool`
      :param factor: how to factorize `cov` to form the projectin matrix.  Can
                     be "eigen" or "svd". The "eigen" option is default and is faster.  But
                     for (nearly) singular cov matrices (such as those generated empirically
                     from ensembles), "svd" is the only way.  Ignored for diagonal `cov`.
      :type factor: `str`

      :returns: the parameter ensemble realized from the gaussian
                distribution
      :rtype: `ParameterEnsemble`

      .. note::

         Only parameters named in `cov` are sampled. Missing parameters are assigned values of
         `pst.parameter_data.parval1` along the corresponding columns of `ParameterEnsemble`
         according to the value of `fill`.
         
         The default `cov` is generated from `pyemu.Cov.from_observation_data`, which assumes
         parameter bounds in `ParameterEnsemble.pst` represent some multiple of parameter
         standard deviations.  Additionally, the default Cov only includes adjustable
         parameters (`partrans` not "tied" or "fixed").
         
         "tied" parameters are not sampled.

      Example::

          pst = pyemu.Pst("my.pst")
          # the easiest way - just relying on weights in pst
          oe1 = pyemu.ParameterEnsemble.from_gaussian_draw(pst)

          # generate the cov explicitly with a sigma_range
          cov = pyemu.Cov.from_parameter_data(pst,sigma_range=6)
          oe2 = pyemu.ParameterEnsemble.from_gaussian_draw(pst,cov=cov)


   .. method:: from_triangular_draw(cls, pst, num_reals=100, fill=True)
      :classmethod:

      generate a `ParameterEnsemble` from a (multivariate) (log) triangular distribution

      :param pst: a control file instance
      :type pst: `pyemu.Pst`
      :param num_reals: number of realizations to generate.  Default is 100
      :type num_reals: `int`, optional
      :param fill: flag to fill in fixed and/or tied parameters with control file
                   values.  Default is True.
      :type fill: `bool`

      :returns: a parameter ensemble drawn from the multivariate (log) triangular
                distribution defined by the parameter upper and lower bounds and initial parameter
                values in `pst`
      :rtype: `ParameterEnsemble`

      .. note::

         respects transformation status in `pst`: fixed and tied parameters are not realized,
         log-transformed parameters are drawn in log space.  The returned `ParameterEnsemble`
         is back transformed (not in log space)
         
         uses numpy.random.triangular

      Example::

          pst = pyemu.Pst("my.pst")
          pe = pyemu.ParameterEnsemble.from_triangular_draw(pst)
          pe.to_csv("my_tri_pe.csv")


   .. method:: from_uniform_draw(cls, pst, num_reals, fill=True)
      :classmethod:

      generate a `ParameterEnsemble` from a (multivariate) (log) uniform
      distribution

      :param pst: a control file instance
      :type pst: `pyemu.Pst`
      :param num_reals: number of realizations to generate.  Default is 100
      :type num_reals: `int`, optional
      :param fill: flag to fill in fixed and/or tied parameters with control file
                   values.  Default is True.
      :type fill: `bool`

      :returns: a parameter ensemble drawn from the multivariate (log) uniform
                distribution defined by the parameter upper and lower bounds `pst`
      :rtype: `ParameterEnsemble`

      .. note::

         respects transformation status in `pst`: fixed and tied parameters are not realized,
         log-transformed parameters are drawn in log space.  The returned `ParameterEnsemble`
         is back transformed (not in log space)
         
         uses numpy.random.uniform

      Example::

          pst = pyemu.Pst("my.pst")
          pe = pyemu.ParameterEnsemble.from_uniform_draw(pst)
          pe.to_csv("my_uni_pe.csv")



   .. method:: from_mixed_draws(cls, pst, how_dict, default='gaussian', num_reals=100, cov=None, sigma_range=6, enforce_bounds=True, partial=False, fill=True)
      :classmethod:

      generate a `ParameterEnsemble` using a mixture of
      distributions.  Available distributions include (log) "uniform", (log) "triangular",
      and (log) "gaussian". log transformation is respected.

      :param pst: a control file
      :type pst: `pyemu.Pst`
      :param how_dict: a dictionary of parameter name keys and
                       "how" values, where "how" can be "uniform","triangular", or "gaussian".
      :type how_dict: `dict`
      :param default: the default distribution to use for parameter not listed
                      in how_dict.  Default is "gaussian".
      :type default: `str`
      :param num_reals: number of realizations to draw.  Default is 100.
      :type num_reals: `int`
      :param cov: an optional Cov instance to use for drawing from gaussian distribution.
                  If None, and "gaussian" is listed in `how_dict` (and/or `default`), then a diagonal
                  covariance matrix is constructed from the parameter bounds in `pst` (with `sigma_range`).
                  Default is None.
      :type cov: `pyemu.Cov`
      :param sigma_range: the number of standard deviations implied by the parameter bounds in the pst.
                          Only used if "gaussian" is in `how_dict` (and/or `default`) and `cov` is None.  Default is 6.
      :type sigma_range: `float`
      :param enforce_bounds: flag to enforce parameter bounds in resulting `ParameterEnsemble`. Only
                             matters if "gaussian" is in values of `how_dict`.  Default is True.
      :type enforce_bounds: `bool`
      :param partial: flag to allow a partial ensemble (not all pars included).  If True, parameters
                      not name in `how_dict` will be sampled using the distribution named as `default`.
                      Default is `False`.
      :type partial: `bool`
      :param fill: flag to fill in fixed and/or tied parameters with control file
                   values.  Default is True.
      :type fill: `bool`


   .. method:: from_parfiles(cls, pst, parfile_names, real_names=None)
      :classmethod:

      create a parameter ensemble from PEST-style parameter value files.
      Accepts parfiles with less than the parameters in the control
      (get NaNs in the ensemble) or extra parameters in the
      parfiles (get dropped)

      :param pst: control file instance
      :type pst: `pyemu.Pst`
      :param parfile_names: par file names
      :type parfile_names: `[str`]
      :param real_names: optional list of realization names.
                         If None, a single integer counter is used
      :type real_names: `str`

      :returns: parameter ensemble loaded from par files
      :rtype: `ParameterEnsemble`


   .. method:: back_transform(self)

      back transform parameters with respect to `partrans` value.

      .. note::

         operates in place (None is returned).
         
         Parameter transform is only related to log_{10} and does not
         include the effects of `scale` and/or `offset`


   .. method:: transform(self)

      transform parameters with respect to `partrans` value.

      .. note::

         operates in place (None is returned).
         
         Parameter transform is only related to log_{10} and does not
         include the effects of `scale` and/or `offset`


   .. method:: add_base(self)

      add the control file `obsval` values as a realization

      .. note::

         replaces the last realization with the current `ParameterEnsemble.pst.parameter_data.parval1` values
         as a new realization named "base"


   .. method:: adj_names(self)
      :property:

      the names of adjustable parameters in `ParameterEnsemble`

      :returns: adjustable parameter names
      :rtype: [`str`]


   .. method:: ubnd(self)
      :property:

      the upper bound vector while respecting current log transform status

      :returns: (log-transformed) upper parameter bounds listed in
                `ParameterEnsemble.pst.parameter_data.parubnd`
      :rtype: `pandas.Series`


   .. method:: lbnd(self)
      :property:

      the lower bound vector while respecting current log transform status

      :returns: (log-transformed) lower parameter bounds listed in
                `ParameterEnsemble.pst.parameter_data.parlbnd`
      :rtype: `pandas.Series`


   .. method:: log_indexer(self)
      :property:

      boolean indexer for log transform

      :returns: boolean array indicating which parameters are log
                transformed
      :rtype: `numpy.ndarray(bool)`


   .. method:: fixed_indexer(self)
      :property:

      boolean indexer for non-adjustable parameters

      :returns: boolean array indicating which parameters have
                `partrans` equal to "log" or "fixed"
      :rtype: `numpy.ndarray(bool)`


   .. method:: project(self, projection_matrix, center_on=None, log=None, enforce_bounds='reset')

      project the ensemble using the null-space Monte Carlo method

      :param projection_matrix: null-space projection operator.
      :type projection_matrix: `pyemu.Matrix`
      :param center_on: the name of the realization to use as the centering
                        point for the null-space differening operation.  If `center_on` is `None`,
                        the `ParameterEnsemble` mean vector is used.  Default is `None`
      :type center_on: `str`
      :param log: for logging progress
      :type log: `pyemu.Logger`, optional
      :param enforce_bounds: parameter bound enforcement option to pass to
                             `ParameterEnsemble.enforce()`.  Valid options are `reset`, `drop`,
                             `scale` or `None`.  Default is `reset`.
      :type enforce_bounds: `str`

      :returns: untransformed, null-space projected ensemble.
      :rtype: `ParameterEnsemble`

      Example::

          ev = pyemu.ErrVar(jco="my.jco") #assumes my.pst exists
          pe = pyemu.ParameterEnsemble.from_gaussian_draw(ev.pst)
          pe_proj = pe.project(ev.get_null_proj(maxsing=25))
          pe_proj.to_csv("proj_par.csv")


   .. method:: enforce(self, how='reset', bound_tol=0.0)

      entry point for bounds enforcement.  This gets called for the
      draw method(s), so users shouldn't need to call this

      :param enforce_bounds: can be 'reset' to reset offending values or 'drop' to drop
                             offending realizations
      :type enforce_bounds: `str`

      Example::

          pst = pyemu.Pst("my.pst")
          pe = pyemu.ParameterEnsemble.from_gaussian_draw()
          pe.enforce(how="scale)
          pe.to_csv("par.csv")



   .. method:: _enforce_scale(self, bound_tol)


   .. method:: _enforce_drop(self, bound_tol)

      enforce parameter bounds on the ensemble by dropping
      violating realizations

      .. note::

         with a large (realistic) number of parameters, the
         probability that any one parameter is out of
         bounds is large, meaning most realization will
         be dropped.


   .. method:: _enforce_reset(self, bound_tol)

      enforce parameter bounds on the ensemble by resetting
      violating vals to bound



.. py:class:: ObservationEnsemble(pst, df, istransformed=False)

   Bases: :class:`pyemu.en.Ensemble`

   Observation noise ensemble in the PEST(++) realm

   :param pst: a control file instance
   :type pst: `pyemu.Pst`
   :param df: a pandas dataframe.  Columns
              should be observation names.  Index is
              treated as realization names
   :type df: `pandas.DataFrame`
   :param istransformed: flag to indicate parameter values
                         are in log space.  Not used for `ObservationEnsemble`
   :type istransformed: `bool`

   Example::

       pst = pyemu.Pst("my.pst")
       oe = pyemu.ObservationEnsemble.from_gaussian_draw(pst)

   .. method:: from_gaussian_draw(cls, pst, cov=None, num_reals=100, by_groups=True, fill=False, factor='eigen')
      :classmethod:

      generate an `ObservationEnsemble` from a (multivariate) gaussian
      distribution

      :param pst: a control file instance.
      :type pst: `pyemu.Pst`
      :param cov: a covariance matrix describing the second
                  moment of the gaussian distribution.  If None, `cov` is
                  generated from the non-zero-weighted observation weights in `pst`.
                  Only observations listed in `cov` are sampled.  Other observations are
                  assigned the `obsval` value from `pst`.
      :type cov: `pyemu.Cov`
      :param num_reals: number of stochastic realizations to generate.  Default
                        is 100
      :type num_reals: `int`
      :param by_groups: flag to generate realzations be observation group.  This
                        assumes no correlation (covariates) between observation groups.
      :type by_groups: `bool`
      :param fill: flag to fill in zero-weighted observations with control file
                   values.  Default is False.
      :type fill: `bool`
      :param factor: how to factorize `cov` to form the projectin matrix.  Can
                     be "eigen" or "svd". The "eigen" option is default and is faster.  But
                     for (nearly) singular cov matrices (such as those generated empirically
                     from ensembles), "svd" is the only way.  Ignored for diagonal `cov`.
      :type factor: `str`

      :returns: the realized `ObservationEnsemble` instance
      :rtype: `ObservationEnsemble`

      .. note::

         Only observations named in `cov` are sampled. Additional, `cov` is processed prior
         to sampling to only include non-zero-weighted observations depending on the value of `fill`.
         So users must take care to make sure observations have been assigned non-zero weights even if `cov`
         is being passed
         
         The default `cov` is generated from `pyemu.Cov.from_observation_data`, which assumes
         observation noise standard deviations are the inverse of the weights listed in `pst`

      Example::

          pst = pyemu.Pst("my.pst")
          # the easiest way - just relying on weights in pst
          oe1 = pyemu.ObservationEnsemble.from_gaussian_draw(pst)

          # generate the cov explicitly
          cov = pyemu.Cov.from_observation_data(pst)
          oe2 = pyemu.ObservationEnsemble.from_gaussian_draw(pst,cov=cov)

          # give all but one observation zero weight.  This will
          # result in an oe with only one randomly sampled observation noise
          # vector since the cov is processed to remove any zero-weighted
          # observations before sampling
          pst.observation_data.loc[pst.nnz_obs_names[1:],"weight] = 0.0
          oe3 = pyemu.ObservationEnsemble.from_gaussian_draw(pst,cov=cov)


   .. method:: phi_vector(self)
      :property:

      vector of L2 norm (phi) for the realizations (rows) of `Ensemble`.

      :returns: series of realization name (`Ensemble.index`) and phi values
      :rtype: `pandas.Series`

      .. note::

         The ObservationEnsemble.pst.weights can be updated prior to calling
         this method to evaluate new weighting strategies


   .. method:: add_base(self)

      add the control file `obsval` values as a realization

      .. note::

         replaces the last realization with the current `ObservationEnsemble.pst.observation_data.obsval` values
             as a new realization named "base"


   .. method:: nonzero(self)
      :property:

      get a new `ObservationEnsemble` of just non-zero weighted observations

      :returns: non-zero weighted observation ensemble.
      :rtype: `ObservationEnsemble`

      .. note::

         The `pst` attribute of the returned `ObservationEnsemble` also only includes
         non-zero weighted observations (and is therefore not valid for running
         with PEST or PEST++)



.. py:class:: Matrix(x=None, row_names=[], col_names=[], isdiagonal=False, autoalign=True)

   Bases: :class:`object`

   Easy linear algebra in the PEST(++) realm

   :param x: numeric values
   :type x: `numpy.ndarray`
   :param row_names: list of row names
   :type row_names: [`str`]
   :param col_names: list of column names
   :type col_names: ['str']
   :param isdigonal: flag if the Matrix is diagonal
   :type isdigonal: `bool`
   :param autoalign: flag to control the autoalignment of Matrix
                     during linear algebra operations
   :type autoalign: `bool`

   Example::

       data = np.random.random((10,10))
       row_names = ["row_{0}".format(i) for i in range(10)]
       col_names = ["col_{0}".format(j) for j in range(10)]
       mat = pyemu.Matrix(x=data,row_names=row_names,col_names=col_names)
       mat.to_binary("mat.jco")


   .. note::

      this class makes heavy use of property decorators to encapsulate
      private attributes

   .. attribute:: integer
      

      

   .. attribute:: double
      

      

   .. attribute:: char
      

      

   .. attribute:: binary_header_dt
      

      

   .. attribute:: binary_rec_dt
      

      

   .. attribute:: coo_rec_dt
      

      

   .. attribute:: par_length
      :annotation: = 12

      

   .. attribute:: obs_length
      :annotation: = 20

      

   .. attribute:: new_par_length
      :annotation: = 200

      

   .. attribute:: new_obs_length
      :annotation: = 200

      

   .. method:: reset_x(self, x, copy=True)

      reset self.__x private attribute

      :param x: the new numeric data
      :type x: `numpy.ndarray`
      :param copy: flag to make a copy of 'x'. Defaule is True
      :type copy: `bool`


   .. method:: __str__(self)

      overload of object.__str__()

      :returns: string representation
      :rtype: `str`


   .. method:: __getitem__(self, item)

      a very crude overload of object.__getitem__().

      :param item: something that can be used as an index
      :type item: `object`

      :returns: an object that is a sub-matrix of `Matrix`
      :rtype: `Matrix`


   .. method:: __pow__(self, power)

      overload of numpy.ndarray.__pow__() operator

      :param power: interpreted as follows: -1 = inverse of self,
                    -0.5 = sqrt of inverse of self,
                    0.5 = sqrt of self. All other positive
                    ints = elementwise self raised to power
      :type power: `float`

      :returns: a new Matrix object
      :rtype: `Matrix`


   .. method:: __sub__(self, other)

      numpy.ndarray.__sub__() overload.  Tries to speedup by
       checking for scalars of diagonal matrices on either side of operator

      :param other: (`int`,`float`,`numpy.ndarray`,`Matrix`): the thing to subtract

      :returns: the result of subtraction
      :rtype: `Matrix`

      .. note::

         if `Matrix` and other (if applicable) have `autoalign` set to `True`,
         both `Matrix` and `other` are aligned based on row and column names.
         If names are not common between the two, this may result in a smaller
         returned `Matrix`


   .. method:: __add__(self, other)

      Overload of numpy.ndarray.__add__().  Tries to speedup by checking for
          scalars of diagonal matrices on either side of operator

      :param other: (`int`,`float`,`numpy.ndarray`,`Matrix`): the thing to add

      :returns: the result of addition
      :rtype: `Matrix`

      .. note::

         if `Matrix` and other (if applicable) have `autoalign` set to `True`,
         both `Matrix` and `other` are aligned based on row and column names.
         If names are not common between the two, this may result in a smaller
         returned `Matrix`


   .. method:: hadamard_product(self, other)

      Overload of numpy.ndarray.__mult__(): element-wise multiplication.
      Tries to speedup by checking for scalars of diagonal matrices on
      either side of operator

      :param other: (`int`,`float`,`numpy.ndarray`,`Matrix`): the thing to multiply

      :returns: the result of multiplication
      :rtype: `Matrix`

      .. note::

         if `Matrix` and other (if applicable) have `autoalign` set to `True`,
         both `Matrix` and `other` are aligned based on row and column names.
         If names are not common between the two, this may result in a smaller
         returned `Matrix`


   .. method:: __mul__(self, other)

      Dot product multiplication overload.  Tries to speedup by
      checking for scalars or diagonal matrices on either side of operator

      :param other: (`int`,`float`,`numpy.ndarray`,`Matrix`): the thing to dot product

      :returns: the result of dot product
      :rtype: `Matrix`

      .. note::

         if `Matrix` and other (if applicable) have `autoalign` set to `True`,
         both `Matrix` and `other` are aligned based on row and column names.
         If names are not common between the two, this may result in a smaller
         returned `Matrix`


   .. method:: __rmul__(self, other)

      Reverse order Dot product multiplication overload.

      :param other: (`int`,`float`,`numpy.ndarray`,`Matrix`): the thing to dot product

      :returns: the result of dot product
      :rtype: `Matrix`

      .. note::

         if `Matrix` and other (if applicable) have `autoalign` set to `True`,
         both `Matrix` and `other` are aligned based on row and column names.
         If names are not common between the two, this may result in a smaller
         returned `Matrix`


   .. method:: __set_svd(self)

      private method to set SVD components.

      Note: this should not be called directly


   .. method:: mult_isaligned(self, other)

      check if matrices are aligned for dot product multiplication

      :param other: the other matrix to check for alignment with
      :type other: `Matrix`

      :returns: True if aligned, False if not aligned
      :rtype: `bool`


   .. method:: element_isaligned(self, other)

      check if matrices are aligned for element-wise operations

      :param other: the other matrix to check for alignment with
      :type other: `Matrix`

      :returns: True if aligned, False if not aligned
      :rtype: `bool`


   .. method:: newx(self)
      :property:

      return a copy of `Matrix.x` attribute

      :returns: a copy `Matrix.x`
      :rtype: `numpy.ndarray`


   .. method:: x(self)
      :property:

      return a reference to `Matrix.x`

      :returns: reference to `Matrix.x`
      :rtype: `numpy.ndarray`


   .. method:: as_2d(self)
      :property:

      get a 2D numeric representation of `Matrix.x`.  If not `isdiagonal`, simply
      return reference to `Matrix.x`, otherwise, constructs and returns
      a 2D, diagonal ndarray

      :returns: numpy.ndarray
      :rtype: `numpy.ndarray`


   .. method:: to_2d(self)

      get a 2D `Matrix` representation of `Matrix`.  If not `Matrix.isdiagonal`, simply
              return a copy of `Matrix`, otherwise, constructs and returns a new `Matrix`
              instance that is stored as diagonal

      :returns: non-diagonal form of `Matrix`
      :rtype: `Martrix`


   .. method:: shape(self)
      :property:

      get the implied, 2D shape of `Matrix`

      :returns: length of 2 tuple
      :rtype: `int`


   .. method:: ncol(self)
      :property:

      length of second dimension

      :returns: number of columns
      :rtype: `int`


   .. method:: nrow(self)
      :property:

      length of first dimension

      :returns: number of rows
      :rtype: `int`


   .. method:: T(self)
      :property:

      wrapper function for `Matrix.transpose()` method

      :returns: transpose of `Matrix`
      :rtype: `Matrix`


   .. method:: transpose(self)
      :property:

      transpose operation of self

      :returns: transpose of `Matrix`
      :rtype: `Matrix`


   .. method:: inv(self)
      :property:

      inversion operation of `Matrix`

      :returns: inverse of `Matrix`
      :rtype: `Matrix`

      .. note:: uses `numpy.linalg.inv` for the inversion

      Example::

          mat = pyemu.Matrix.from_binary("my.jco")
          mat_inv = mat.inv
          mat_inv.to_binary("my_inv.jco")


   .. method:: get_maxsing_from_s(s, eigthresh=1e-05)
      :staticmethod:

      static method to work out the maxsing for a
      given singular spectrum

      :param s: 1-D array of singular values. This
                array should come from calling either `numpy.linalg.svd`
                or from the `pyemu.Matrix.s.x` attribute
      :type s: `numpy.ndarray`
      :param eigthresh: the ratio of smallest to largest
                        singular value to retain.  Since it is assumed that
                        `s` is sorted from largest to smallest, once a singular value
                        is reached that yields a ratio with the first (largest)
                        singular value, the index of this singular is returned.
      :type eigthresh: `float`

      :returns: the index of the singular value whos ratio with the
                first singular value is less than or equal to `eigthresh`
      :rtype: `int`


   .. method:: get_maxsing(self, eigthresh=1e-05)

      Get the number of singular components with a singular
      value ratio greater than or equal to eigthresh

       Args:
          eigthresh (`float`): the ratio of smallest to largest
              singular value to retain.  Since it is assumed that
              `s` is sorted from largest to smallest, once a singular value
              is reached that yields a ratio with the first (largest)
              singular value, the index of this singular is returned.

      :returns: the index of the singular value whos ratio with the
                first singular value is less than or equal to `eigthresh`
      :rtype: `int`

      .. note::

         this method calls the static method `Matrix.get_maxsing_from_s()`
         with `Matrix.s.x`


   .. method:: pseudo_inv_components(self, maxsing=None, eigthresh=1e-05, truncate=True)

      Get the (optionally) truncated SVD components

      :param maxsing: the number of singular components to use.  If None,
                      `maxsing` is calculated using `Matrix.get_maxsing()` and `eigthresh`
      :type maxsing: `int`, optional
      :param `eigthresh`: (`float`, optional): the ratio of largest to smallest singular
                          components to use for truncation.  Ignored if maxsing is not None.  Default is
                          1.0e-5
      :param truncate: flag to truncate components. If False, U, s, and V will be
                       zeroed out at locations greater than `maxsing` instead of truncated. Default is True
      :type truncate: `bool`

      :returns: tuple containing

                - **Matrix**: (optionally truncated) left singular vectors
                - **Matrix**: (optionally truncated) singular value matrix
                - **Matrix**: (optionally truncated) right singular vectors

      Example::

          mat = pyemu.Matrix.from_binary("my.jco")
          u,s,v = mat.pseudo_inv_components(maxsing=10)
          resolution_matrix = v * v.T
          resolution_matrix.to_ascii("resol.mat")


   .. method:: pseudo_inv(self, maxsing=None, eigthresh=1e-05)

      The pseudo inverse of self.  Formed using truncated singular
      value decomposition and `Matrix.pseudo_inv_components`

      :param maxsing: the number of singular components to use.  If None,
                      `maxsing` is calculated using `Matrix.get_maxsing()` and `eigthresh`
      :type maxsing: `int`, optional
      :param `eigthresh`: (`float`, optional): the ratio of largest to smallest singular
                          components to use for truncation.  Ignored if maxsing is not None.  Default is
                          1.0e-5

      :returns: the truncated-SVD pseudo inverse of `Matrix` (V_1 * s_1^-1 * U^T)
      :rtype: `Matrix`


   .. method:: sqrt(self)
      :property:

      element-wise square root operation

      :returns: element-wise square root of `Matrix`
      :rtype: `Matrix`

      .. note:: uses `numpy.sqrt`


   .. method:: full_s(self)
      :property:

      Get the full singular value matrix

      :returns: full singular value matrix.  Shape is `(max(Matrix.shape),max(Matrix.shape))`
                with zeros along the diagonal from `min(Matrix.shape)` to `max(Matrix.shape)`
      :rtype: `Matrix`


   .. method:: s(self)
      :property:

      the singular value (diagonal) Matrix

      :returns: singular value matrix.  shape is `(min(Matrix.shape),min(Matrix.shape))`
      :rtype: `Matrix`


   .. method:: u(self)
      :property:

      the left singular vector Matrix

      :returns: left singular vectors.  Shape is `(Matrix.shape[0], Matrix.shape[0])`
      :rtype: `Matrix`


   .. method:: v(self)
      :property:

      the right singular vector Matrix

      :returns: right singular vectors.  Shape is `(Matrix.shape[1], Matrix.shape[1])`
      :rtype: `Matrix`


   .. method:: zero2d(self)
      :property:

      get an 2D instance of self with all zeros

      :returns: `Matrix of zeros`
      :rtype: `Matrix`


   .. method:: find_rowcol_indices(names, row_names, col_names, axis=None)
      :staticmethod:

      fast(er) look of row and colum names indices

      :param names: list of names to look for in `row_names` and/or `col_names` names
      :type names: [`str`]
      :param row_names: list of row names
      :type row_names: [`str`]
      :param col_names: list of column names
      :type col_names: [`str`]
      :param axis: axis to search along.  If None, search both.
                   Default is `None`
      :type axis: `int`, optional

      :returns: array of (integer) index locations.  If `axis` is
                `None`, a 2 `numpy.ndarrays` of both row and column name indices is returned
      :rtype: `numpy.ndarray`


   .. method:: indices(self, names, axis=None)

      get the row and col indices of names. If axis is None, two ndarrays
              are returned, corresponding the indices of names for each axis

      :param names: list of names to look for in `row_names` and/or `col_names` names
      :type names: [`str`]
      :param row_names: list of row names
      :type row_names: [`str`]
      :param col_names: list of column names
      :type col_names: [`str`]
      :param axis: axis to search along.  If None, search both.
                   Default is `None`
      :type axis: `int`, optional

      :returns: array of (integer) index locations.  If `axis` is
                `None`, a 2 `numpy.ndarrays` of both row and column name indices is returned
      :rtype: `numpy.ndarray`

      .. note:: thin wrapper around `Matrix.find_rowcol_indices` static method


   .. method:: align(self, names, axis=None)

      reorder `Matrix` by names in place.  If axis is None, reorder both indices

      :param names: names in `Matrix.row_names` and\or `Matrix.col_names`
      :type names: ['str']
      :param axis: the axis to reorder. if None, reorder both axes
      :type axis: `int`, optional


   .. method:: get(self, row_names=None, col_names=None, drop=False)

      get a new `Matrix` instance ordered on row_names or col_names

      :param row_names: row_names for new Matrix.  If `None`,
                        all row_names are used.
      :type row_names: ['str'], optional
      :param col_names: col_names for new Matrix. If `None`,
                        all col_names are used.
      :type col_names: ['str'], optional
      :param drop: flag to remove row_names and/or col_names from this `Matrix`
      :type drop: `bool`

      :returns: a new `Matrix`
      :rtype: `Matrix`


   .. method:: copy(self)

      get a copy of `Matrix`

      :returns: copy of this `Matrix`
      :rtype: `Matrix`


   .. method:: drop(self, names, axis)

      drop elements from `Matrix` in place

      :param names: list of names to drop
      :type names: ['str']
      :param axis: the axis to drop from. must be in [0,1]
      :type axis: `int`


   .. method:: extract(self, row_names=None, col_names=None)

      wrapper method that `Matrix.gets()` then `Matrix.drops()` elements.
      one of row_names or col_names must be not None.

      :param row_names: row_names to extract.  If `None`,
                        all row_names are retained.
      :type row_names: ['str'], optional
      :param col_names: col_names to extract. If `None`,
                        all col_names are retained.
      :type col_names: ['str'], optional

      :returns: the extract sub-matrix defined by `row_names` and/or `col_names`
      :rtype: `Matrix`


   .. method:: get_diagonal_vector(self, col_name='diag')

      Get a new Matrix instance that is the diagonal of self.  The
      shape of the new matrix is (self.shape[0],1).  Self must be square

      :param col_name: the name of the single column in the new Matrix
      :type col_name: `str`

      :returns: vector-shaped `Matrix` instance of the diagonal of this `Matrix`
      :rtype: `Matrix`


   .. method:: to_coo(self, filename, droptol=None, chunk=None)

      write an extended PEST-format binary file.  The data format is
      [int,int,float] for i,j,value.  It is autodetected during
      the read with `Matrix.from_binary()`.

      :param filename: filename to save binary file
      :type filename: `str`
      :param droptol: absolute value tolerance to make values
                      smaller `droptol` than zero.  Default is None (no dropping)
      :type droptol: `float`
      :param chunk: number of elements to write in a single pass.
                    Default is `None`, which writes the entire numeric part of the
                    `Matrix` at once. This is faster but requires more memory.
      :type chunk: `int`


   .. method:: to_binary(self, filename, droptol=None, chunk=None)

      write a PEST-compatible binary file.  The format is the same
      as the format used to storage a PEST Jacobian matrix

      :param filename: filename to save binary file
      :type filename: `str`
      :param droptol: absolute value tolerance to make values
                      smaller `droptol` than zero.  Default is None (no dropping)
      :type droptol: `float`
      :param chunk: number of elements to write in a single pass.
                    Default is `None`, which writes the entire numeric part of the
                    `Matrix` at once. This is faster but requires more memory.
      :type chunk: `int`


   .. method:: from_binary(cls, filename)
      :classmethod:

      class method load from PEST-compatible binary file into a
      Matrix instance

      :param filename: filename to read
      :type filename: `str`

      :returns: `Matrix` loaded from binary file
      :rtype: `Matrix`

      Example::

          mat = pyemu.Matrix.from_binary("my.jco")
          cov = pyemi.Cov.from_binary("large_cov.jcb")


   .. method:: read_binary(filename)
      :staticmethod:

      static method to read PEST-format binary files

      :param filename: filename to read
      :type filename: `str`

      :returns: tuple containing

                - **numpy.ndarray**: the numeric values in the file
                - **['str']**: list of row names
                - **[`str`]**: list of col_names


   .. method:: from_fortranfile(filename)
      :staticmethod:

      a binary load method to accommodate one of the many
          bizarre fortran binary writing formats

      :param filename: name of the binary matrix file
      :type filename: `str`

      :returns: tuple containing

                - **numpy.ndarray**: the numeric values in the file
                - **['str']**: list of row names
                - **[`str`]**: list of col_names


   .. method:: to_ascii(self, filename, icode=2)

      write a PEST-compatible ASCII Matrix/vector file

      :param filename: filename to write to
      :type filename: `str`

      icode (`int`, optional): PEST-style info code for matrix style.
          Default is 2


   .. method:: from_ascii(cls, filename)
      :classmethod:

      load a PEST-compatible ASCII matrix/vector file into a
      `Matrix` instance

      :param filename: name of the file to read
      :type filename: `str`

      :returns: `Matrix` loaded from ASCII file
      :rtype: `Matrix`

      Example::

          mat = pyemu.Matrix.from_ascii("my.mat")
          cov = pyemi.Cov.from_ascii("my.cov")


   .. method:: read_ascii(filename)
      :staticmethod:

      read a PEST-compatible ASCII matrix/vector file

      :param filename: file to read from
      :type filename: `str`

      :returns: tuple containing

                - **numpy.ndarray**: numeric values
                - **['str']**: list of row names
                - **[`str`]**: list of column names
                - **bool**: diagonal flag


   .. method:: df(self)

      wrapper of Matrix.to_dataframe()


   .. method:: from_dataframe(cls, df)
      :classmethod:

      class method to create a new `Matrix` instance from a
       `pandas.DataFrame`

      :param df: dataframe
      :type df: `pandas.DataFrame`

      :returns: `Matrix` instance derived from `df`.
      :rtype: `Matrix`

      Example::

          df = pd.read_csv("my.csv")
          mat = pyemu.Matrix.from_dataframe(df)


   .. method:: from_names(cls, row_names, col_names, isdiagonal=False, autoalign=True, random=False)
      :classmethod:

      class method to create a new Matrix instance from
      row names and column names, filled with trash

      :param row_names: row names for the new `Matrix`
      :type row_names: ['str']
      :param col_names: col_names for the new matrix
      :type col_names: ['str']
      :param isdiagonal: flag for diagonal matrix. Default is False
      :type isdiagonal: `bool`, optional
      :param autoalign: flag for autoaligning new matrix
                        during linear algebra calcs. Default is True
      :type autoalign: `bool`, optional
      :param random: flag for contents of the trash matrix.
                     If True, fill with random numbers, if False, fill with zeros
                     Default is False
      :type random: `bool`

      :returns: the new Matrix instance
      :rtype: `Matrix`


   .. method:: to_dataframe(self)

      return a pandas.DataFrame representation of `Matrix`

      :returns: a dataframe derived from `Matrix`
      :rtype: `pandas.DataFrame`


   .. method:: extend(self, other)

      extend `Matrix` with the elements of other.

      Args:
      other (`Matrix`):  the Matrix to extend self by
      inplace (`bool`): inplace = True not implemented

      :returns: new, extended `Matrix`
      :rtype: `Matrix`



.. py:class:: Jco(x=None, row_names=[], col_names=[], isdiagonal=False, autoalign=True)

   Bases: :class:`pyemu.mat.mat_handler.Matrix`

   a thin wrapper class to get more intuitive attribute names.  Functions
   exactly like `Matrix`

   .. method:: __init(self, **kwargs)

      Jco constuctor takes the same arguments as Matrix.

      :param \*\*kwargs: constructor arguments for `Matrix`
      :type \*\*kwargs: `dict`

      .. rubric:: Example

      jco = pyemu.Jco.from_binary("my.jco")


   .. method:: par_names(self)
      :property:

      thin wrapper around `Matrix.col_names`

      :returns: a list of parameter names
      :rtype: [`str`]


   .. method:: obs_names(self)
      :property:

      thin wrapper around `Matrix.row_names`

      :returns: a list of observation names
      :rtype: ['str']


   .. method:: npar(self)
      :property:

      number of parameters in the Jco

      :returns: number of parameters (columns)
      :rtype: `int`


   .. method:: nobs(self)
      :property:

      number of observations in the Jco

      :returns: number of observations (rows)
      :rtype: `int`


   .. method:: from_pst(cls, pst, random=False)
      :classmethod:

      construct a new empty Jco from a control file filled
      with trash

      :param pst: a pest control file instance.  If type is 'str',
                  `pst` is loaded from filename
      :type pst: `pyemu.Pst`
      :param random: flag for contents of the trash matrix.
                     If True, fill with random numbers, if False, fill with zeros
                     Default is False
      :type random: `bool`

      :returns: the new Jco instance
      :rtype: `Jco`



.. py:class:: Cov(x=None, names=[], row_names=[], col_names=[], isdiagonal=False, autoalign=True)

   Bases: :class:`pyemu.mat.mat_handler.Matrix`

   Diagonal and/or dense Covariance matrices

   :param x: numeric values
   :type x: `numpy.ndarray`
   :param names: list of row and column names
   :type names: [`str`]
   :param isdigonal: flag if the Matrix is diagonal
   :type isdigonal: `bool`
   :param autoalign: flag to control the autoalignment of Matrix during
                     linear algebra operations
   :type autoalign: `bool`

   Example::

       data = np.random.random((10,10))
       names = ["par_{0}".format(i) for i in range(10)]
       mat = pyemu.Cov(x=data,names=names)
       mat.to_binary("mat.jco")

   .. note::

      `row_names` and `col_names` args are supported in the contructor
      so support inheritance.  However, users should only pass `names`

   .. method:: identity(self)
      :property:

      get an identity `Cov` of the same shape

      :returns: new `Cov` instance with identity matrix
      :rtype: `Cov`


   .. method:: zero(self)
      :property:

      get an instance of `Cov` with all zeros

      :returns: new `Cov` instance with zeros
      :rtype: `Cov`


   .. method:: condition_on(self, conditioning_elements)

      get a new Covariance object that is conditional on knowing some
      elements.  uses Schur's complement for conditional Covariance
      propagation

      :param conditioning_elements: list of names of elements to condition on
      :type conditioning_elements: ['str']

      :returns: new conditional `Cov` that assumes `conditioning_elements` have become known
      :rtype: `Cov`


   .. method:: names(self)
      :property:

      wrapper for getting row_names.  row_names == col_names for Cov

      :returns: list of names
      :rtype: [`str`]


   .. method:: replace(self, other)

      replace elements in the covariance matrix with elements from other.
      if other is not diagonal, then this `Cov` becomes non diagonal

      :param `Cov`: the Cov to replace elements in this `Cov` with

      .. note:: operates in place


   .. method:: to_uncfile(self, unc_file, covmat_file='cov.mat', var_mult=1.0, include_path=True)

      write a PEST-compatible uncertainty file

      :param unc_file: filename of the uncertainty file
      :type unc_file: `str`
      :param covmat_file: covariance matrix filename. Default is
                          "Cov.mat".  If None, and Cov.isdiaonal, then a standard deviation
                          form of the uncertainty file is written.  Exception raised if `covmat_file` is `None`
                          and not `Cov.isdiagonal`
      :type covmat_file: `str`
      :param var_mult: variance multiplier for the covmat_file entry
      :type var_mult: `float`

      Example::

          cov = pyemu.Cov.from_parameter_data(pst)
          cov.to_uncfile("my.unc")


   .. method:: from_obsweights(cls, pst_file)
      :classmethod:

      instantiates a `Cov` instance from observation weights in
      a PEST control file.

      :param pst_file: pest control file name
      :type pst_file: `str`

      :returns: a diagonal observation noise covariance matrix derived from the
                weights in the pest control file.  Zero-weighted observations
                are included with a weight of 1.0e-30
      :rtype: `Cov`

      .. note:: Calls `Cov.from_observation_data()`

      Example::

          obscov = pyemu.Cov.from_obsweights("my.pst")



   .. method:: from_observation_data(cls, pst)
      :classmethod:

      instantiates a `Cov` from pyemu.Pst.observation_data

      :param pst: control file instance
      :type pst: `pyemu.Pst`

      :returns: a diagonal observation noise covariance matrix derived from the
                weights in the pest control file.  Zero-weighted observations
                are included with a weight of 1.0e-30
      :rtype: `Cov`

      Example::

          obscov = pyemu.Cov.from_observation_data(pst)


   .. method:: from_parbounds(cls, pst_file, sigma_range=4.0, scale_offset=True)
      :classmethod:

      Instantiates a `Cov` from a pest control file parameter data section using
      parameter bounds as a proxy for uncertainty.


      :param pst_file: pest control file name
      :type pst_file: `str`
      :param sigma_range: defines range of upper bound - lower bound in terms of standard
                          deviation (sigma). For example, if sigma_range = 4, the bounds
                          represent 4 * sigma.  Default is 4.0, representing approximately
                          95% confidence of implied normal distribution
      :type sigma_range: `float`
      :param scale_offset: flag to apply scale and offset to parameter upper and lower
                           bounds before calculating varaince. In some cases, not applying scale and
                           offset can result in undefined (log) variance.  Default is True.
      :type scale_offset: `bool`

      :returns: diagonal parameter `Cov` matrix created from parameter bounds
      :rtype: `Cov`

      .. note:: Calls `Cov.from_parameter_data()`


   .. method:: from_parameter_data(cls, pst, sigma_range=4.0, scale_offset=True)
      :classmethod:

      Instantiates a `Cov` from a pest control file parameter data section using
      parameter bounds as a proxy for uncertainty.


      :param pst_file: pest control file name
      :type pst_file: `str`
      :param sigma_range: defines range of upper bound - lower bound in terms of standard
                          deviation (sigma). For example, if sigma_range = 4, the bounds
                          represent 4 * sigma.  Default is 4.0, representing approximately
                          95% confidence of implied normal distribution
      :type sigma_range: `float`
      :param scale_offset: flag to apply scale and offset to parameter upper and lower
                           bounds before calculating varaince. In some cases, not applying scale and
                           offset can result in undefined (log) variance.  Default is True.
      :type scale_offset: `bool`

      :returns: diagonal parameter `Cov` matrix created from parameter bounds
      :rtype: `Cov`

      .. note:: Calls `Cov.from_parameter_data()`


   .. method:: from_uncfile(cls, filename)
      :classmethod:

      instaniates a `Cov` from a PEST-compatible uncertainty file

      :param filename: uncertainty file name
      :type filename: `str`

      :returns: `Cov` instance from uncertainty file
      :rtype: `Cov`

      Example::

          cov = pyemu.Cov.from_uncfile("my.unc")


   .. method:: _get_uncfile_dimensions(filename)
      :staticmethod:

      quickly read an uncertainty file to find the dimensions


   .. method:: identity_like(cls, other)
      :classmethod:

      Get an identity matrix Cov instance like other `Cov`

      :param other: other matrix - must be square
      :type other: `Matrix`

      :returns: new identity matrix `Cov` with shape of `other`
      :rtype: `Cov`


   .. method:: to_pearson(self)

      Convert Cov instance to Pearson correlation coefficient
      matrix

      :returns: A `Matrix` of correlation coefs.  Return type is `Matrix`
                on purpose so that it is clear the returned instance is not a Cov
      :rtype: `Matrix`



.. py:class:: Pst(filename, load=True, resfile=None)

   Bases: :class:`object`

   All things PEST(++) control file

   :param filename: the name of the control file
   :type filename: `str`
   :param load: flag to load the control file. Default is True
   :type load: `bool`, optional
   :param resfile: corresponding residual file.  If `None`, a residual file
                   with the control file base name is sought.  Default is `None`
   :type resfile: `str`, optional

   .. note::

      This class is the primary mechanism for dealing with PEST control files.  Support is provided
      for constructing new control files as well as manipulating existing control files.

   Example::

       pst = pyemu.Pst("my.pst")
       pst.control_data.noptmax = -1
       pst.write("my_new.pst")

   .. attribute:: parameter_data
      

      '* parameter data' information.  Columns are
      standard PEST variable names

      Example::

          pst.parameter_data.loc[:,"partrans"] = "log"
          pst.parameter_data.loc[:,"parubnd"] = 10.0

      :type: pandas.DataFrame


   .. attribute:: observation_data
      

      '* observation data' information.  Columns are standard PEST
      variable names

      Example::

          pst.observation_data.loc[:,"weight"] = 1.0
          pst.observation_data.loc[:,"obgnme"] = "obs_group"

      :type: pandas.DataFrame


   .. attribute:: prior_information
      

      '* prior information' data.  Columns are standard PEST
      variable names

      :type: pandas.DataFrame


   .. attribute:: control_data
      

      '* control data' information.
      Access with standard PEST variable names

      Example::

          pst.control_data.noptmax = 2
          pst.control_data.pestmode = "estimation"

      :type: pyemu.pst.pst_controldata.ControlData


   .. attribute:: svd_data
      

      '* singular value decomposition' section information.
      Access with standard PEST variable names

      Example::

          pst.svd_data.maxsing = 100

      :type: pyemu.pst.pst_controldata.SvdData


   .. attribute:: reg_data
      

      '* regularization' section information.
      Access with standard PEST variable names.

      Example::

          pst.reg_data.phimlim = 1.00 #yeah right!

      :type: pyemu.pst.pst_controldata.RegData


   .. method:: __setattr__(self, key, value)

      Implement setattr(self, name, value).


   .. method:: from_par_obs_names(cls, par_names=['par1'], obs_names=['obs1'])
      :classmethod:

      construct a shell `Pst` instance from parameter and observation names

      :param par_names: list of parameter names.  Default is [`par1`]
      :type par_names: [`str`]
      :param obs_names: list of observation names.  Default is [`obs1`]
      :type obs_names: [`str`]

      .. note::

         While this method works, it does not make template or instruction files.
         Users are encouraged to use `Pst.from_io_files()` for more usefulness

      Example::

          par_names = ["par1","par2"]
          obs_names = ["obs1","obs2"]
          pst = pyemu.Pst.from_par_obs_names(par_names,obs_names)


   .. method:: phi(self)
      :property:

      get the weighted total objective function.

      :returns: sum of squared residuals
      :rtype: `float`

      .. note:: Requires `Pst.res` (the residuals file) to be available


   .. method:: phi_components(self)
      :property:

      get the individual components of the total objective function

      :returns: dictionary of observation group, contribution to total phi
      :rtype: `dict`

      .. note:: Requires `Pst.res` (the residuals file) to be available


   .. method:: phi_components_normalized(self)
      :property:

      get the individual components of the total objective function
          normalized to the total PHI being 1.0

      :returns: dictionary of observation group,
                normalized contribution to total phi
      :rtype: `dict`

      .. note:: Requires `Pst.res` (the residuals file) to be available


   .. method:: set_res(self, res)

      reset the private `Pst.res` attribute.

      :param res: (`pandas.DataFrame` or `str`): something to use as Pst.res attribute.
                  If `res` is `str`, a dataframe is read from file `res`


   .. method:: res(self)
      :property:

      get the residuals dataframe attribute

      :returns: a dataframe containing the
                residuals information.
      :rtype: `pandas.DataFrame`

      .. note::

         if the Pst.__res attribute has not been loaded,
             this call loads the res dataframe from a file


   .. method:: nprior(self)
      :property:

      number of prior information equations

      :returns: the number of prior info equations
      :rtype: `int`


   .. method:: nnz_obs(self)
      :property:

      get the number of non-zero weighted observations

      :returns: the number of non-zeros weighted observations
      :rtype: `int`


   .. method:: nobs(self)
      :property:

      get the number of observations

      :returns: the number of observations
      :rtype: `int`


   .. method:: npar_adj(self)
      :property:

      get the number of adjustable parameters (not fixed or tied)

      :returns: the number of adjustable parameters
      :rtype: `int`


   .. method:: npar(self)
      :property:

      get number of parameters

      :returns: the number of parameters
      :rtype: `int`


   .. method:: forecast_names(self)
      :property:

      get the forecast names from the pestpp options (if any).
      Returns None if no forecasts are named

      :returns: a list of forecast names.
      :rtype: [`str`]


   .. method:: obs_groups(self)
      :property:

      get the observation groups

      :returns: a list of unique observation groups
      :rtype: [`str`]


   .. method:: nnz_obs_groups(self)
      :property:

      get the observation groups that contain at least one non-zero weighted
       observation

      :returns: a list of observation groups that contain at
                least one non-zero weighted observation
      :rtype: [`str`]


   .. method:: adj_par_groups(self)
      :property:

      get the parameter groups with atleast one adjustable parameter

      :returns: a list of parameter groups with
                at least one adjustable parameter
      :rtype: [`str`]


   .. method:: par_groups(self)
      :property:

      get the parameter groups

      :returns: a list of parameter groups
      :rtype: [`str`]


   .. method:: prior_groups(self)
      :property:

      get the prior info groups

      :returns: a list of prior information groups
      :rtype: [`str`]


   .. method:: prior_names(self)
      :property:

      get the prior information names

      :returns: a list of prior information names
      :rtype: [`str`]


   .. method:: par_names(self)
      :property:

      get the parameter names

      :returns: a list of parameter names
      :rtype: [`str`]


   .. method:: adj_par_names(self)
      :property:

      get the adjustable (not fixed or tied) parameter names

      :returns: list of adjustable (not fixed or tied)
                parameter names
      :rtype: [`str`]


   .. method:: obs_names(self)
      :property:

      get the observation names

      :returns: a list of observation names
      :rtype: [`str`]


   .. method:: nnz_obs_names(self)
      :property:

      get the non-zero weight observation names

      :returns: a list of non-zero weighted observation names
      :rtype: [`str`]


   .. method:: zero_weight_obs_names(self)
      :property:

      get the zero-weighted observation names

      :returns: a list of zero-weighted observation names
      :rtype: [`str`]


   .. method:: estimation(self)
      :property:

      check if the control_data.pestmode is set to estimation

      :returns: True if `control_data.pestmode` is estmation, False otherwise
      :rtype: `bool`


   .. method:: tied(self)
      :property:

      list of tied parameter names

      :returns: a dataframe of tied parameter information.
                Columns of `tied` are `parnme` and `partied`.  Returns `None` if
                no tied parameters are found.
      :rtype: `pandas.DataFrame`


   .. method:: _read_df(f, nrows, names, converters, defaults=None)
      :staticmethod:

      a private method to read part of an open file into a pandas.DataFrame.

      :param f: open file handle
      :type f: `file`
      :param nrows: number of rows to read
      :type nrows: `int`
      :param names: names to set the columns of the dataframe with
      :type names: [`str`]
      :param converters: dictionary of lambda functions to convert strings
                         to numerical format
      :type converters: `dict`
      :param defaults: dictionary of default values to assign columns.
                       Default is None
      :type defaults: `dict`

      :returns: dataframe of control file section info
      :rtype: `pandas.DataFrame`


   .. method:: _read_line_comments(self, f, forgive)


   .. method:: _read_section_comments(self, f, forgive)


   .. method:: _parse_external_line(line, pst_path='.')
      :staticmethod:


   .. method:: _parse_path_agnostic(filename)
      :staticmethod:


   .. method:: _cast_df_from_lines(section, lines, fieldnames, converters, defaults, alias_map={}, pst_path='.')
      :staticmethod:


   .. method:: _cast_prior_df_from_lines(self, section, lines, pst_path='.')


   .. method:: _load_version2(self, filename)

      load a version 2 control file


   .. method:: load(self, filename)

      entry point load the pest control file.

      :param filename: pst filename
      :type filename: `str`

      .. note:: This method is called from the `Pst` construtor unless the `load` arg is `False`.


   .. method:: _parse_pestpp_line(self, line)


   .. method:: _update_control_section(self)

      private method to synchronize the control section counters with the
      various parts of the control file.  This is usually called during the
      Pst.write() method.


   .. method:: rectify_pgroups(self)

      synchronize parameter groups section with the parameter data section

      .. note::

         This method is called during `Pst.write()` to make sure all parameter
         groups named in `* parameter data` are included.  This is so users
         don't have to manually keep this section up.  This method can also be
         called during control file modifications to see what parameter groups
         are present and prepare for modifying the default values in the `* parameter
         group` section

      Example::

          pst = pyemu.Pst("my.pst")
          pst.parameter_data.loc["par1","pargp"] = "new_group"
          pst.rectify_groups()
          pst.parameter_groups.loc["new_group","derinc"] = 1.0



   .. method:: _parse_pi_par_names(self)

      private method to get the parameter names from prior information
      equations.  Sets a 'names' column in Pst.prior_information that is a list
      of parameter names



   .. method:: add_pi_equation(self, par_names, pilbl=None, rhs=0.0, weight=1.0, obs_group='pi_obgnme', coef_dict={})

      a helper to construct a new prior information equation.

      :param par_names: parameter names in the equation
      :type par_names: [`str`]
      :param pilbl: name to assign the prior information equation.  If None,
                    a generic equation name is formed. Default is None
      :type pilbl: `str`
      :param rhs: the right-hand side of the pi equation
      :type rhs: `float`
      :param weight: the weight of the equation
      :type weight: `float`
      :param obs_group: the observation group for the equation. Default is 'pi_obgnme'
      :type obs_group: `str`
      :param coef_dict: a dictionary of parameter name, coefficient pairs to assign
                        leading coefficients for one or more parameters in the equation.
                        If a parameter is not listed, 1.0 is used for its coefficients.
                        Default is {}
      :type coef_dict: `dict`


   .. method:: rectify_pi(self)

      rectify the prior information equation with the current state of the
      parameter_data dataframe.


      .. note::

         Equations that list fixed, tied or missing parameters
         are removed completely even if adjustable parameters are also
         listed in the equation. This method is called during Pst.write()


   .. method:: _write_df(self, name, f, df, formatters, columns)


   .. method:: sanity_checks(self)

      some basic check for strangeness

      .. note::

         checks for duplicate names, atleast 1 adjustable parameter
         and at least 1 non-zero-weighted observation


   .. method:: _write_version2(self, new_filename, use_pst_path=True, pst_rel_path='.')


   .. method:: write(self, new_filename, version=1)

      main entry point to write a pest control file.

      :param new_filename: name of the new pest control file
      :type new_filename: `str`
      :param version: flag for which version of control file to write (must be 1 or 2).
                      if None, uses Pst._version, which set in the constructor and modified
                      during the load
      :type version: `int`

      Example::

          pst = pyemu.Pst("my.pst")
          pst.parrep("my.par")
          pst.write(my_new.pst")


   .. method:: _write_version1(self, new_filename)

      write a version 1 pest control file





   .. method:: bounds_report(self, iterations=None)

      report how many parameters are at bounds. If ensemble, the base enbsemble member is evaluated

      :param iterations: a list of iterations for which a bounds report is requested
                         If None, all iterations for which `par` files are located are reported. Default
                         is None
      :type iterations: [`int`]

      :returns:

                a pandas DataFrame object with rows being parameter groups and columns
                    <iter>_num_at_ub, <iter>_num_at_lb, and <iter>_total_at_bounds
                    row 0 is total at bounds, subsequent rows correspond with groups
      :rtype: `df`

      .. rubric:: Example

      pst = pyemu.Pst("my.pst")
      df = pst.bound_report(iterations=[0,2,3])


   .. method:: get(self, par_names=None, obs_names=None)

      get a new pst object with subset of parameters and/or observations

      :param par_names: a list of parameter names to have in the new Pst instance.
                        If None, all parameters are in the new Pst instance. Default
                        is None
      :type par_names: [`str`]
      :param obs_names: a list of observation names to have in the new Pst instance.
                        If None, all observations are in teh new Pst instance. Default
                        is None
      :type obs_names: [`str`]

      :returns: a new Pst instance
      :rtype: `Pst`

      .. note::

         passing `par_names` as `None` and `obs_names` as `None` effectively
         generates a copy of the current `Pst`


   .. method:: parrep(self, parfile=None, enforce_bounds=True)

      replicates the pest parrep util. replaces the parval1 field in the
          parameter data section dataframe with values in a PEST parameter file

      :param parfile: parameter file to use.  If None, try to find and use
                      a parameter file that corresponds to the case name.
                      Default is None
      :type parfile: `str`, optional
      :param enforce_bounds: flag to enforce parameter bounds after parameter values are updated.
                             This is useful because PEST and PEST++ round the parameter values in the
                             par file, which may cause slight bound violations.  Default is `True`
      :type enforce_bounds: `bool`, optional


   .. method:: adjust_weights_discrepancy(self, resfile=None, original_ceiling=True, bygroups=False)

      adjusts the weights of each non-zero weight observation based
      on the residual in the pest residual file so each observations contribution
      to phi is 1.0 (e.g. Mozorov's discrepancy principal)

      :param resfile: residual file name.  If None, try to use a residual file
                      with the Pst case name.  Default is None
      :type resfile: `str`
      :param original_ceiling: flag to keep weights from increasing - this is
                               generally a good idea. Default is True
      :type original_ceiling: `bool`
      :param bygroups: flag to adjust weights by groups. If False, the weight
                       of each non-zero weighted observation is adjusted individually. If True,
                       intergroup weighting is preserved (the contribution to each group is used)
                       but this may result in some strangeness if some observations in a group have
                       a really low phi already.
      :type bygroups: `bool`

      Example::

          pst = pyemu.Pst("my.pst")
          print(pst.phi) #assumes "my.res" is colocated with "my.pst"
          pst.adjust_weights_discrepancy()
          print(pst.phi) # phi should equal number of non-zero observations


   .. method:: _adjust_weights_by_phi_components(self, components, original_ceiling)

      private method that resets the weights of observations by group to account for
      residual phi components.

      :param components: a dictionary of obs group:phi contribution pairs
      :type components: `dict`
      :param original_ceiling: flag to keep weights from increasing.
      :type original_ceiling: `bool`


   .. method:: __reset_weights(self, target_phis, res_idxs, obs_idxs)

      private method to reset weights based on target phi values
      for each group.  This method should not be called directly

      :param target_phis: target phi contribution for groups to reweight
      :type target_phis: `dict`
      :param res_idxs: the index positions of each group of interest
                       in the res dataframe
      :type res_idxs: `dict`
      :param obs_idxs: the index positions of each group of interest
                       in the observation data dataframe
      :type obs_idxs: `dict`


   .. method:: _adjust_weights_by_list(self, obslist, weight)

      a private method to reset the weight for a list of observation names.  Supports the
      data worth analyses in pyemu.Schur class.  This method only adjusts
      observation weights in the current weight is nonzero.  User beware!

      :param obslist: list of observation names
      :type obslist: [`str`]
      :param weight: new weight to assign
      :type weight: `float`


   .. method:: adjust_weights(self, obs_dict=None, obsgrp_dict=None)

      reset the weights of observations or observation groups to contribute a specified
      amount to the composite objective function

      :param obs_dict: dictionary of observation name,new contribution pairs
      :type obs_dict: `dict`, optional
      :param obsgrp_dict: dictionary of obs group name,contribution pairs
      :type obsgrp_dict: `dict`, optional

      .. note::

         if all observations in a named obs group have zero weight, they will all be
         assigned a non-zero weight so that the request phi contribution
         can be met.  Similarly, any observations listed in obs_dict with zero
         weight will also be reset. User beware!

      Example::

          pst = pyemu.Pst("my.pst")

          # adjust a single observation
          pst.adjust_weights(obs_dict={"obs1":10})

          # adjust a single observation group
          pst.adjust_weights(obsgrp_dict={"group1":100.0})

          # make all non-zero weighted groups have a contribution of 100.0
          balanced_groups = {grp:100 for grp in pst.nnz_obs_groups}
          pst.adjust_weights(obsgrp_dict=balanced_groups)


   .. method:: proportional_weights(self, fraction_stdev=1.0, wmax=100.0, leave_zero=True)

      setup  weights inversely proportional to the observation value

      :param fraction_stdev: the fraction portion of the observation
                             val to treat as the standard deviation.  set to 1.0 for
                             inversely proportional.  Default is 1.0
      :type fraction_stdev: `float`, optional
      :param wmax: maximum weight to allow.  Default is 100.0
      :type wmax: `float`, optional
      :param leave_zero: flag to leave existing zero weights.
                         Default is True
      :type leave_zero: `bool`, optional


   .. method:: calculate_pertubations(self)

      experimental method to calculate finite difference parameter
      pertubations.

      .. note::

         The pertubation values are added to the
         `Pst.parameter_data` attribute - user beware!


   .. method:: build_increments(self)

      experimental method to calculate parameter increments for use
      in the finite difference pertubation calculations

      .. note:: user beware!


   .. method:: add_transform_columns(self)

      add transformed values to the `Pst.parameter_data` attribute

      .. note::

         adds `parval1_trans`, `parlbnd_trans` and `parubnd_trans` to
         `Pst.parameter_data`


   .. method:: enforce_bounds(self)

      enforce bounds violation

      .. note:: cheap enforcement of simply bringing violators back in bounds


   .. method:: from_io_files(cls, tpl_files, in_files, ins_files, out_files, pst_filename=None, pst_path=None)
      :classmethod:

      create a Pst instance from model interface files.

      :param tpl_files: list of template file names
      :type tpl_files: [`str`]
      :param in_files: list of model input file names (pairs with template files)
      :type in_files: [`str`]
      :param ins_files: list of instruction file names
      :type ins_files: [`str`]
      :param out_files: list of model output file names (pairs with instruction files)
      :type out_files: [`str`]
      :param pst_filename: name of control file to write.  If None, no file is written.
                           Default is None
      :type pst_filename: `str`
      :param pst_path: the path from the control file to the IO files.  For example, if the
                       control will be in the same directory as the IO files, then `pst_path` should be '.'.
                       Default is None, which doesnt do any path manipulation on the I/O file names
      :type pst_path: 'str'

      :returns: new control file instance with parameter and observation names
                found in `tpl_files` and `ins_files`, repsectively.
      :rtype: `Pst`

      .. note::

         calls `pyemu.helpers.pst_from_io_files()`
         
         Assigns generic values for parameter info.  Tries to use INSCHEK
         to set somewhat meaningful observation values
         
         all file paths are relatively to where python is running.

      Example::

          tpl_files = ["my.tpl"]
          in_files = ["my.in"]
          ins_files = ["my.ins"]
          out_files = ["my.out"]
          pst = pyemu.Pst.from_io_files(tpl_files,in_files,ins_files,out_files)
          pst.control_data.noptmax = 0
          pst.write("my.pst)




   .. method:: add_parameters(self, template_file, in_file=None, pst_path=None)

      add new parameters to an existing control file

      :param template_file: template file with (possibly) some new parameters
      :type template_file: `str`
      :param in_file: model input file. If None, template_file.replace('.tpl','') is used.
                      Default is None.
      :type in_file: `str`
      :param pst_path: the path to append to the template_file and in_file in the control file.  If
                       not None, then any existing path in front of the template or in file is split off
                       and pst_path is prepended.  If python is being run in a directory other than where the control
                       file will reside, it is useful to pass `pst_path` as `.`.  Default is None
      :type pst_path: `str`

      :returns: the data for the new parameters that were added.
                If no new parameters are in the new template file, returns None
      :rtype: `pandas.DataFrame`

      .. note:: populates the new parameter information with default values

      Example::

          pst = pyemu.Pst(os.path.join("template","my.pst"))
          pst.add_parameters(os.path.join("template","new_pars.dat.tpl",pst_path=".")
          pst.write(os.path.join("template","my_new.pst")


   .. method:: add_observations(self, ins_file, out_file=None, pst_path=None, inschek=True)

      add new observations to a control file

      :param ins_file: instruction file with exclusively new observation names
      :type ins_file: `str`
      :param out_file: model output file.  If None, then ins_file.replace(".ins","") is used.
                       Default is None
      :type out_file: `str`
      :param pst_path: the path to append to the instruction file and out file in the control file.  If
                       not None, then any existing path in front of the template or in file is split off
                       and pst_path is prepended.  If python is being run in a directory other than where the control
                       file will reside, it is useful to pass `pst_path` as `.`. Default is None
      :type pst_path: `str`
      :param inschek: flag to try to process the existing output file using the `pyemu.InstructionFile`
                      class.  If successful, processed outputs are used as obsvals
      :type inschek: `bool`

      :returns: the data for the new observations that were added
      :rtype: `pandas.DataFrame`

      .. note:: populates the new observation information with default values

      Example::

          pst = pyemu.Pst(os.path.join("template", "my.pst"))
          pst.add_observations(os.path.join("template","new_obs.dat.ins"), pst_path=".")
          pst.write(os.path.join("template", "my_new.pst")


   .. method:: write_input_files(self, pst_path='.')

      writes model input files using template files and current `parval1` values.

      :param pst_path: the path to where control file and template files reside.
                       Default is '.'
      :type pst_path: `str`

      .. note::

         adds "parval1_trans" column to Pst.parameter_data that includes the
         effect of scale and offset

      Example::

          pst = pyemu.Pst("my.pst")

          # load final parameter values
          pst.parrep("my.par")

          # write new model input files with final parameter values
          pst.write_input_files()


   .. method:: process_output_files(self, pst_path='.')

      processing the model output files using the instruction files
      and existing model output files.

      :param pst_path: relative path from where python is running to
                       where the control file, instruction files and model output files
                       are located.  Default is "." (current python directory)
      :type pst_path: `str`

      :returns: model output values
      :rtype: `pandas.Series`

      .. note::

         requires a complete set of model input files at relative path
         from where python is running to `pst_path`


   .. method:: get_res_stats(self, nonzero=True)

      get some common residual stats by observation group.

      :param nonzero: calculate stats using only nonzero-weighted observations.  This may seem
                      obsvious to most users, but you never know....
      :type nonzero: `bool`

      :returns: a dataframe with columns for groups names and indices of statistic name.
      :rtype: `pd.DataFrame`

      .. note::

         Stats are derived from the current obsvals, weights and grouping in
         `Pst.observation_data` and the `modelled` values in `Pst.res`.  The
         key here is 'current' because if obsval, weights and/or groupings have
         changed in `Pst.observation_data` since the residuals file was generated
         then the current values for `obsval`, `weight` and `group` are used
         
         the normalized RMSE is normalized against the obsval range (max - min)


   .. method:: _stats_rss(df)
      :staticmethod:


   .. method:: _stats_mean(df)
      :staticmethod:


   .. method:: _stats_mae(df)
      :staticmethod:


   .. method:: _stats_rmse(df)
      :staticmethod:


   .. method:: _stats_nrmse(df)
      :staticmethod:


   .. method:: plot(self, kind=None, **kwargs)

      method to plot various parts of the control.  This is sweet as!

      :param kind: options are 'prior' (prior parameter histograms, '1to1' (line of equality
                   and sim vs res), 'obs_v_sim' (time series using datetime suffix), 'phi_pie'
                   (pie chart of phi components)
      :type kind: `str`
      :param kwargs: optional args for plots that are passed to pyemu plot helpers and ultimately
                     to matplotlib
      :type kwargs: `dict`

      .. note:: Depending on 'kind' argument, a multipage pdf is written

      Example::

          pst = pyemu.Pst("my.pst")
          pst.plot(kind="1to1") # requires Pst.res
          pst.plot(kind="prior")
          pst.plot(kind="phi_pie")



   .. method:: write_par_summary_table(self, filename=None, group_names=None, sigma_range=4.0)

      write a stand alone parameter summary latex table


      :param filename: latex filename. If None, use <case>.par.tex. If `filename` is "none", no table
                       is writtenDefault is None
      :type filename: `str`
      :param group_names: par group names : table names. For example {"w0":"well stress period 1"}.
                          Default is None
      :type group_names: `dict`
      :param sigma_range: number of standard deviations represented by parameter bounds.  Default
                          is 4.0, implying 95% confidence bounds
      :type sigma_range: `float`

      :returns: the summary parameter group dataframe
      :rtype: `pandas.DataFrame`

      Example::

          pst = pyemu.Pst("my.pst")
          pst.write_par_summary_table(filename="par.tex")


   .. method:: write_obs_summary_table(self, filename=None, group_names=None)

      write a stand alone observation summary latex table


      :param filename: latex filename. If `filename` is "none", no table is written.
                       If None, use <case>.par.tex. Default is None
      :type filename: `str`
      :param group_names: obs group names : table names. For example {"hds":"simulated groundwater level"}.
                          Default is None
      :type group_names: `dict`

      :returns: the summary observation group dataframe
      :rtype: `pandas.DataFrame`

      Example::

          pst = pyemu.Pst("my.pst")
          pst.write_obs_summary_table(filename="obs.tex")


   .. method:: _is_less_const(name)
      :staticmethod:


   .. method:: less_than_obs_constraints(self)
      :property:

      get the names of the observations that
      are listed as active less than inequality constraints.

      :returns: names of obseravtions that are non-zero weighted less
                than constraints (`obgnme` starts with 'l\_' or "less")
      :rtype: `pandas.Series`

      .. note:: Zero-weighted obs are skipped


   .. method:: less_than_pi_constraints(self)
      :property:

      get the names of the prior information eqs that
      are listed as active less than inequality constraints.

      :returns: names of prior information that are non-zero weighted
                less than constraints (`obgnme` starts with "l\_" or "less")
      :rtype: `pandas.Series`

      .. note:: Zero-weighted pi are skipped


   .. method:: _is_greater_const(name)
      :staticmethod:


   .. method:: greater_than_obs_constraints(self)
      :property:

      get the names of the observations that
      are listed as active greater than inequality constraints.

      :returns: names obseravtions that are non-zero weighted
                greater than constraints (`obgnme` startsiwth "g\_" or "greater")
      :rtype: `pandas.Series`

      .. note:: Zero-weighted obs are skipped


   .. method:: greater_than_pi_constraints(self)
      :property:

      get the names of the prior information eqs that
      are listed as active greater than inequality constraints.

      :returns: `pandas.Series` names of prior information that are non-zero weighted
                greater than constraints (`obgnme` startsiwth "g\_" or "greater")

      .. note:: Zero-weighted pi are skipped


   .. method:: get_par_change_limits(self)

      calculate the various parameter change limits used in pest.


      :returns: a copy of `Pst.parameter_data`
                with columns for relative and factor change limits
      :rtype: `pandas.DataFrame`

      .. note::

         does not yet support absolute parameter change limits!
         
         Works in control file values space (not log transformed space).  Also
         adds columns for effective upper and lower which account for par bounds and the
         value of parchglim


   .. method:: get_adj_pars_at_bounds(self, frac_tol=0.01)

      get list of adjustable parameter at/near bounds

      :param frac_tol: fractional tolerance of distance to bound.  For upper bound,
                       the value `parubnd * (1-frac_tol)` is used, lower bound uses `parlbnd * (1.0 + frac_tol)`
      :type frac_tol: 'float`

      :returns:

                - **[`str`]**: list of parameters at/near lower bound
                - **[`str`]**: list of parameters at/near upper bound
      :rtype: tuple containing


   .. method:: try_parse_name_metadata(self)

      try to add meta data columns to parameter and observation data based on
      item names.  Used with the PstFrom process.

      Note: metadata is identified in key-value pairs that are separated by a colon.
          each key-value pair is separated from others by underscore



.. py:class:: ParameterEnsemble(pst, df, istransformed=False)

   Bases: :class:`pyemu.en.Ensemble`

   Parameter ensembles in the PEST(++) realm

   :param pst: a control file instance
   :type pst: `pyemu.Pst`
   :param df: a pandas dataframe.  Columns
              should be parameter names.  Index is
              treated as realization names
   :type df: `pandas.DataFrame`
   :param istransformed: flag to indicate parameter values
                         are in log space (if `partrans` is "log" in `pst`)
   :type istransformed: `bool`

   Example::

       pst = pyemu.Pst("my.pst")
       pe = pyemu.ParameterEnsemble.from_gaussian_draw(pst)

   .. method:: from_gaussian_draw(cls, pst, cov=None, num_reals=100, by_groups=True, fill=True, factor='eigen')
      :classmethod:

      generate a `ParameterEnsemble` from a (multivariate) (log) gaussian
      distribution

      :param pst: a control file instance.
      :type pst: `pyemu.Pst`
      :param cov: a covariance matrix describing the second
                  moment of the gaussian distribution.  If None, `cov` is
                  generated from the bounds of the adjustable parameters in `pst`.
                  the (log) width of the bounds is assumed to represent a multiple of
                  the parameter standard deviation (this is the `sigma_range` argument
                  that can be passed to `pyemu.Cov.from_parameter_data`).
      :type cov: `pyemu.Cov`
      :param num_reals: number of stochastic realizations to generate.  Default
                        is 100
      :type num_reals: `int`
      :param by_groups: flag to generate realzations be parameter group.  This
                        assumes no correlation (covariates) between parameter groups.  For large
                        numbers of parameters, this help prevent memories but is slower.
      :type by_groups: `bool`
      :param fill: flag to fill in fixed and/or tied parameters with control file
                   values.  Default is True.
      :type fill: `bool`
      :param factor: how to factorize `cov` to form the projectin matrix.  Can
                     be "eigen" or "svd". The "eigen" option is default and is faster.  But
                     for (nearly) singular cov matrices (such as those generated empirically
                     from ensembles), "svd" is the only way.  Ignored for diagonal `cov`.
      :type factor: `str`

      :returns: the parameter ensemble realized from the gaussian
                distribution
      :rtype: `ParameterEnsemble`

      .. note::

         Only parameters named in `cov` are sampled. Missing parameters are assigned values of
         `pst.parameter_data.parval1` along the corresponding columns of `ParameterEnsemble`
         according to the value of `fill`.
         
         The default `cov` is generated from `pyemu.Cov.from_observation_data`, which assumes
         parameter bounds in `ParameterEnsemble.pst` represent some multiple of parameter
         standard deviations.  Additionally, the default Cov only includes adjustable
         parameters (`partrans` not "tied" or "fixed").
         
         "tied" parameters are not sampled.

      Example::

          pst = pyemu.Pst("my.pst")
          # the easiest way - just relying on weights in pst
          oe1 = pyemu.ParameterEnsemble.from_gaussian_draw(pst)

          # generate the cov explicitly with a sigma_range
          cov = pyemu.Cov.from_parameter_data(pst,sigma_range=6)
          oe2 = pyemu.ParameterEnsemble.from_gaussian_draw(pst,cov=cov)


   .. method:: from_triangular_draw(cls, pst, num_reals=100, fill=True)
      :classmethod:

      generate a `ParameterEnsemble` from a (multivariate) (log) triangular distribution

      :param pst: a control file instance
      :type pst: `pyemu.Pst`
      :param num_reals: number of realizations to generate.  Default is 100
      :type num_reals: `int`, optional
      :param fill: flag to fill in fixed and/or tied parameters with control file
                   values.  Default is True.
      :type fill: `bool`

      :returns: a parameter ensemble drawn from the multivariate (log) triangular
                distribution defined by the parameter upper and lower bounds and initial parameter
                values in `pst`
      :rtype: `ParameterEnsemble`

      .. note::

         respects transformation status in `pst`: fixed and tied parameters are not realized,
         log-transformed parameters are drawn in log space.  The returned `ParameterEnsemble`
         is back transformed (not in log space)
         
         uses numpy.random.triangular

      Example::

          pst = pyemu.Pst("my.pst")
          pe = pyemu.ParameterEnsemble.from_triangular_draw(pst)
          pe.to_csv("my_tri_pe.csv")


   .. method:: from_uniform_draw(cls, pst, num_reals, fill=True)
      :classmethod:

      generate a `ParameterEnsemble` from a (multivariate) (log) uniform
      distribution

      :param pst: a control file instance
      :type pst: `pyemu.Pst`
      :param num_reals: number of realizations to generate.  Default is 100
      :type num_reals: `int`, optional
      :param fill: flag to fill in fixed and/or tied parameters with control file
                   values.  Default is True.
      :type fill: `bool`

      :returns: a parameter ensemble drawn from the multivariate (log) uniform
                distribution defined by the parameter upper and lower bounds `pst`
      :rtype: `ParameterEnsemble`

      .. note::

         respects transformation status in `pst`: fixed and tied parameters are not realized,
         log-transformed parameters are drawn in log space.  The returned `ParameterEnsemble`
         is back transformed (not in log space)
         
         uses numpy.random.uniform

      Example::

          pst = pyemu.Pst("my.pst")
          pe = pyemu.ParameterEnsemble.from_uniform_draw(pst)
          pe.to_csv("my_uni_pe.csv")



   .. method:: from_mixed_draws(cls, pst, how_dict, default='gaussian', num_reals=100, cov=None, sigma_range=6, enforce_bounds=True, partial=False, fill=True)
      :classmethod:

      generate a `ParameterEnsemble` using a mixture of
      distributions.  Available distributions include (log) "uniform", (log) "triangular",
      and (log) "gaussian". log transformation is respected.

      :param pst: a control file
      :type pst: `pyemu.Pst`
      :param how_dict: a dictionary of parameter name keys and
                       "how" values, where "how" can be "uniform","triangular", or "gaussian".
      :type how_dict: `dict`
      :param default: the default distribution to use for parameter not listed
                      in how_dict.  Default is "gaussian".
      :type default: `str`
      :param num_reals: number of realizations to draw.  Default is 100.
      :type num_reals: `int`
      :param cov: an optional Cov instance to use for drawing from gaussian distribution.
                  If None, and "gaussian" is listed in `how_dict` (and/or `default`), then a diagonal
                  covariance matrix is constructed from the parameter bounds in `pst` (with `sigma_range`).
                  Default is None.
      :type cov: `pyemu.Cov`
      :param sigma_range: the number of standard deviations implied by the parameter bounds in the pst.
                          Only used if "gaussian" is in `how_dict` (and/or `default`) and `cov` is None.  Default is 6.
      :type sigma_range: `float`
      :param enforce_bounds: flag to enforce parameter bounds in resulting `ParameterEnsemble`. Only
                             matters if "gaussian" is in values of `how_dict`.  Default is True.
      :type enforce_bounds: `bool`
      :param partial: flag to allow a partial ensemble (not all pars included).  If True, parameters
                      not name in `how_dict` will be sampled using the distribution named as `default`.
                      Default is `False`.
      :type partial: `bool`
      :param fill: flag to fill in fixed and/or tied parameters with control file
                   values.  Default is True.
      :type fill: `bool`


   .. method:: from_parfiles(cls, pst, parfile_names, real_names=None)
      :classmethod:

      create a parameter ensemble from PEST-style parameter value files.
      Accepts parfiles with less than the parameters in the control
      (get NaNs in the ensemble) or extra parameters in the
      parfiles (get dropped)

      :param pst: control file instance
      :type pst: `pyemu.Pst`
      :param parfile_names: par file names
      :type parfile_names: `[str`]
      :param real_names: optional list of realization names.
                         If None, a single integer counter is used
      :type real_names: `str`

      :returns: parameter ensemble loaded from par files
      :rtype: `ParameterEnsemble`


   .. method:: back_transform(self)

      back transform parameters with respect to `partrans` value.

      .. note::

         operates in place (None is returned).
         
         Parameter transform is only related to log_{10} and does not
         include the effects of `scale` and/or `offset`


   .. method:: transform(self)

      transform parameters with respect to `partrans` value.

      .. note::

         operates in place (None is returned).
         
         Parameter transform is only related to log_{10} and does not
         include the effects of `scale` and/or `offset`


   .. method:: add_base(self)

      add the control file `obsval` values as a realization

      .. note::

         replaces the last realization with the current `ParameterEnsemble.pst.parameter_data.parval1` values
         as a new realization named "base"


   .. method:: adj_names(self)
      :property:

      the names of adjustable parameters in `ParameterEnsemble`

      :returns: adjustable parameter names
      :rtype: [`str`]


   .. method:: ubnd(self)
      :property:

      the upper bound vector while respecting current log transform status

      :returns: (log-transformed) upper parameter bounds listed in
                `ParameterEnsemble.pst.parameter_data.parubnd`
      :rtype: `pandas.Series`


   .. method:: lbnd(self)
      :property:

      the lower bound vector while respecting current log transform status

      :returns: (log-transformed) lower parameter bounds listed in
                `ParameterEnsemble.pst.parameter_data.parlbnd`
      :rtype: `pandas.Series`


   .. method:: log_indexer(self)
      :property:

      boolean indexer for log transform

      :returns: boolean array indicating which parameters are log
                transformed
      :rtype: `numpy.ndarray(bool)`


   .. method:: fixed_indexer(self)
      :property:

      boolean indexer for non-adjustable parameters

      :returns: boolean array indicating which parameters have
                `partrans` equal to "log" or "fixed"
      :rtype: `numpy.ndarray(bool)`


   .. method:: project(self, projection_matrix, center_on=None, log=None, enforce_bounds='reset')

      project the ensemble using the null-space Monte Carlo method

      :param projection_matrix: null-space projection operator.
      :type projection_matrix: `pyemu.Matrix`
      :param center_on: the name of the realization to use as the centering
                        point for the null-space differening operation.  If `center_on` is `None`,
                        the `ParameterEnsemble` mean vector is used.  Default is `None`
      :type center_on: `str`
      :param log: for logging progress
      :type log: `pyemu.Logger`, optional
      :param enforce_bounds: parameter bound enforcement option to pass to
                             `ParameterEnsemble.enforce()`.  Valid options are `reset`, `drop`,
                             `scale` or `None`.  Default is `reset`.
      :type enforce_bounds: `str`

      :returns: untransformed, null-space projected ensemble.
      :rtype: `ParameterEnsemble`

      Example::

          ev = pyemu.ErrVar(jco="my.jco") #assumes my.pst exists
          pe = pyemu.ParameterEnsemble.from_gaussian_draw(ev.pst)
          pe_proj = pe.project(ev.get_null_proj(maxsing=25))
          pe_proj.to_csv("proj_par.csv")


   .. method:: enforce(self, how='reset', bound_tol=0.0)

      entry point for bounds enforcement.  This gets called for the
      draw method(s), so users shouldn't need to call this

      :param enforce_bounds: can be 'reset' to reset offending values or 'drop' to drop
                             offending realizations
      :type enforce_bounds: `str`

      Example::

          pst = pyemu.Pst("my.pst")
          pe = pyemu.ParameterEnsemble.from_gaussian_draw()
          pe.enforce(how="scale)
          pe.to_csv("par.csv")



   .. method:: _enforce_scale(self, bound_tol)


   .. method:: _enforce_drop(self, bound_tol)

      enforce parameter bounds on the ensemble by dropping
      violating realizations

      .. note::

         with a large (realistic) number of parameters, the
         probability that any one parameter is out of
         bounds is large, meaning most realization will
         be dropped.


   .. method:: _enforce_reset(self, bound_tol)

      enforce parameter bounds on the ensemble by resetting
      violating vals to bound



.. py:class:: ObservationEnsemble(pst, df, istransformed=False)

   Bases: :class:`pyemu.en.Ensemble`

   Observation noise ensemble in the PEST(++) realm

   :param pst: a control file instance
   :type pst: `pyemu.Pst`
   :param df: a pandas dataframe.  Columns
              should be observation names.  Index is
              treated as realization names
   :type df: `pandas.DataFrame`
   :param istransformed: flag to indicate parameter values
                         are in log space.  Not used for `ObservationEnsemble`
   :type istransformed: `bool`

   Example::

       pst = pyemu.Pst("my.pst")
       oe = pyemu.ObservationEnsemble.from_gaussian_draw(pst)

   .. method:: from_gaussian_draw(cls, pst, cov=None, num_reals=100, by_groups=True, fill=False, factor='eigen')
      :classmethod:

      generate an `ObservationEnsemble` from a (multivariate) gaussian
      distribution

      :param pst: a control file instance.
      :type pst: `pyemu.Pst`
      :param cov: a covariance matrix describing the second
                  moment of the gaussian distribution.  If None, `cov` is
                  generated from the non-zero-weighted observation weights in `pst`.
                  Only observations listed in `cov` are sampled.  Other observations are
                  assigned the `obsval` value from `pst`.
      :type cov: `pyemu.Cov`
      :param num_reals: number of stochastic realizations to generate.  Default
                        is 100
      :type num_reals: `int`
      :param by_groups: flag to generate realzations be observation group.  This
                        assumes no correlation (covariates) between observation groups.
      :type by_groups: `bool`
      :param fill: flag to fill in zero-weighted observations with control file
                   values.  Default is False.
      :type fill: `bool`
      :param factor: how to factorize `cov` to form the projectin matrix.  Can
                     be "eigen" or "svd". The "eigen" option is default and is faster.  But
                     for (nearly) singular cov matrices (such as those generated empirically
                     from ensembles), "svd" is the only way.  Ignored for diagonal `cov`.
      :type factor: `str`

      :returns: the realized `ObservationEnsemble` instance
      :rtype: `ObservationEnsemble`

      .. note::

         Only observations named in `cov` are sampled. Additional, `cov` is processed prior
         to sampling to only include non-zero-weighted observations depending on the value of `fill`.
         So users must take care to make sure observations have been assigned non-zero weights even if `cov`
         is being passed
         
         The default `cov` is generated from `pyemu.Cov.from_observation_data`, which assumes
         observation noise standard deviations are the inverse of the weights listed in `pst`

      Example::

          pst = pyemu.Pst("my.pst")
          # the easiest way - just relying on weights in pst
          oe1 = pyemu.ObservationEnsemble.from_gaussian_draw(pst)

          # generate the cov explicitly
          cov = pyemu.Cov.from_observation_data(pst)
          oe2 = pyemu.ObservationEnsemble.from_gaussian_draw(pst,cov=cov)

          # give all but one observation zero weight.  This will
          # result in an oe with only one randomly sampled observation noise
          # vector since the cov is processed to remove any zero-weighted
          # observations before sampling
          pst.observation_data.loc[pst.nnz_obs_names[1:],"weight] = 0.0
          oe3 = pyemu.ObservationEnsemble.from_gaussian_draw(pst,cov=cov)


   .. method:: phi_vector(self)
      :property:

      vector of L2 norm (phi) for the realizations (rows) of `Ensemble`.

      :returns: series of realization name (`Ensemble.index`) and phi values
      :rtype: `pandas.Series`

      .. note::

         The ObservationEnsemble.pst.weights can be updated prior to calling
         this method to evaluate new weighting strategies


   .. method:: add_base(self)

      add the control file `obsval` values as a realization

      .. note::

         replaces the last realization with the current `ObservationEnsemble.pst.observation_data.obsval` values
             as a new realization named "base"


   .. method:: nonzero(self)
      :property:

      get a new `ObservationEnsemble` of just non-zero weighted observations

      :returns: non-zero weighted observation ensemble.
      :rtype: `ObservationEnsemble`

      .. note::

         The `pst` attribute of the returned `ObservationEnsemble` also only includes
         non-zero weighted observations (and is therefore not valid for running
         with PEST or PEST++)



.. py:class:: Cov(x=None, names=[], row_names=[], col_names=[], isdiagonal=False, autoalign=True)

   Bases: :class:`pyemu.mat.mat_handler.Matrix`

   Diagonal and/or dense Covariance matrices

   :param x: numeric values
   :type x: `numpy.ndarray`
   :param names: list of row and column names
   :type names: [`str`]
   :param isdigonal: flag if the Matrix is diagonal
   :type isdigonal: `bool`
   :param autoalign: flag to control the autoalignment of Matrix during
                     linear algebra operations
   :type autoalign: `bool`

   Example::

       data = np.random.random((10,10))
       names = ["par_{0}".format(i) for i in range(10)]
       mat = pyemu.Cov(x=data,names=names)
       mat.to_binary("mat.jco")

   .. note::

      `row_names` and `col_names` args are supported in the contructor
      so support inheritance.  However, users should only pass `names`

   .. method:: identity(self)
      :property:

      get an identity `Cov` of the same shape

      :returns: new `Cov` instance with identity matrix
      :rtype: `Cov`


   .. method:: zero(self)
      :property:

      get an instance of `Cov` with all zeros

      :returns: new `Cov` instance with zeros
      :rtype: `Cov`


   .. method:: condition_on(self, conditioning_elements)

      get a new Covariance object that is conditional on knowing some
      elements.  uses Schur's complement for conditional Covariance
      propagation

      :param conditioning_elements: list of names of elements to condition on
      :type conditioning_elements: ['str']

      :returns: new conditional `Cov` that assumes `conditioning_elements` have become known
      :rtype: `Cov`


   .. method:: names(self)
      :property:

      wrapper for getting row_names.  row_names == col_names for Cov

      :returns: list of names
      :rtype: [`str`]


   .. method:: replace(self, other)

      replace elements in the covariance matrix with elements from other.
      if other is not diagonal, then this `Cov` becomes non diagonal

      :param `Cov`: the Cov to replace elements in this `Cov` with

      .. note:: operates in place


   .. method:: to_uncfile(self, unc_file, covmat_file='cov.mat', var_mult=1.0, include_path=True)

      write a PEST-compatible uncertainty file

      :param unc_file: filename of the uncertainty file
      :type unc_file: `str`
      :param covmat_file: covariance matrix filename. Default is
                          "Cov.mat".  If None, and Cov.isdiaonal, then a standard deviation
                          form of the uncertainty file is written.  Exception raised if `covmat_file` is `None`
                          and not `Cov.isdiagonal`
      :type covmat_file: `str`
      :param var_mult: variance multiplier for the covmat_file entry
      :type var_mult: `float`

      Example::

          cov = pyemu.Cov.from_parameter_data(pst)
          cov.to_uncfile("my.unc")


   .. method:: from_obsweights(cls, pst_file)
      :classmethod:

      instantiates a `Cov` instance from observation weights in
      a PEST control file.

      :param pst_file: pest control file name
      :type pst_file: `str`

      :returns: a diagonal observation noise covariance matrix derived from the
                weights in the pest control file.  Zero-weighted observations
                are included with a weight of 1.0e-30
      :rtype: `Cov`

      .. note:: Calls `Cov.from_observation_data()`

      Example::

          obscov = pyemu.Cov.from_obsweights("my.pst")



   .. method:: from_observation_data(cls, pst)
      :classmethod:

      instantiates a `Cov` from pyemu.Pst.observation_data

      :param pst: control file instance
      :type pst: `pyemu.Pst`

      :returns: a diagonal observation noise covariance matrix derived from the
                weights in the pest control file.  Zero-weighted observations
                are included with a weight of 1.0e-30
      :rtype: `Cov`

      Example::

          obscov = pyemu.Cov.from_observation_data(pst)


   .. method:: from_parbounds(cls, pst_file, sigma_range=4.0, scale_offset=True)
      :classmethod:

      Instantiates a `Cov` from a pest control file parameter data section using
      parameter bounds as a proxy for uncertainty.


      :param pst_file: pest control file name
      :type pst_file: `str`
      :param sigma_range: defines range of upper bound - lower bound in terms of standard
                          deviation (sigma). For example, if sigma_range = 4, the bounds
                          represent 4 * sigma.  Default is 4.0, representing approximately
                          95% confidence of implied normal distribution
      :type sigma_range: `float`
      :param scale_offset: flag to apply scale and offset to parameter upper and lower
                           bounds before calculating varaince. In some cases, not applying scale and
                           offset can result in undefined (log) variance.  Default is True.
      :type scale_offset: `bool`

      :returns: diagonal parameter `Cov` matrix created from parameter bounds
      :rtype: `Cov`

      .. note:: Calls `Cov.from_parameter_data()`


   .. method:: from_parameter_data(cls, pst, sigma_range=4.0, scale_offset=True)
      :classmethod:

      Instantiates a `Cov` from a pest control file parameter data section using
      parameter bounds as a proxy for uncertainty.


      :param pst_file: pest control file name
      :type pst_file: `str`
      :param sigma_range: defines range of upper bound - lower bound in terms of standard
                          deviation (sigma). For example, if sigma_range = 4, the bounds
                          represent 4 * sigma.  Default is 4.0, representing approximately
                          95% confidence of implied normal distribution
      :type sigma_range: `float`
      :param scale_offset: flag to apply scale and offset to parameter upper and lower
                           bounds before calculating varaince. In some cases, not applying scale and
                           offset can result in undefined (log) variance.  Default is True.
      :type scale_offset: `bool`

      :returns: diagonal parameter `Cov` matrix created from parameter bounds
      :rtype: `Cov`

      .. note:: Calls `Cov.from_parameter_data()`


   .. method:: from_uncfile(cls, filename)
      :classmethod:

      instaniates a `Cov` from a PEST-compatible uncertainty file

      :param filename: uncertainty file name
      :type filename: `str`

      :returns: `Cov` instance from uncertainty file
      :rtype: `Cov`

      Example::

          cov = pyemu.Cov.from_uncfile("my.unc")


   .. method:: _get_uncfile_dimensions(filename)
      :staticmethod:

      quickly read an uncertainty file to find the dimensions


   .. method:: identity_like(cls, other)
      :classmethod:

      Get an identity matrix Cov instance like other `Cov`

      :param other: other matrix - must be square
      :type other: `Matrix`

      :returns: new identity matrix `Cov` with shape of `other`
      :rtype: `Cov`


   .. method:: to_pearson(self)

      Convert Cov instance to Pearson correlation coefficient
      matrix

      :returns: A `Matrix` of correlation coefs.  Return type is `Matrix`
                on purpose so that it is clear the returned instance is not a Cov
      :rtype: `Matrix`



.. py:class:: Matrix(x=None, row_names=[], col_names=[], isdiagonal=False, autoalign=True)

   Bases: :class:`object`

   Easy linear algebra in the PEST(++) realm

   :param x: numeric values
   :type x: `numpy.ndarray`
   :param row_names: list of row names
   :type row_names: [`str`]
   :param col_names: list of column names
   :type col_names: ['str']
   :param isdigonal: flag if the Matrix is diagonal
   :type isdigonal: `bool`
   :param autoalign: flag to control the autoalignment of Matrix
                     during linear algebra operations
   :type autoalign: `bool`

   Example::

       data = np.random.random((10,10))
       row_names = ["row_{0}".format(i) for i in range(10)]
       col_names = ["col_{0}".format(j) for j in range(10)]
       mat = pyemu.Matrix(x=data,row_names=row_names,col_names=col_names)
       mat.to_binary("mat.jco")


   .. note::

      this class makes heavy use of property decorators to encapsulate
      private attributes

   .. attribute:: integer
      

      

   .. attribute:: double
      

      

   .. attribute:: char
      

      

   .. attribute:: binary_header_dt
      

      

   .. attribute:: binary_rec_dt
      

      

   .. attribute:: coo_rec_dt
      

      

   .. attribute:: par_length
      :annotation: = 12

      

   .. attribute:: obs_length
      :annotation: = 20

      

   .. attribute:: new_par_length
      :annotation: = 200

      

   .. attribute:: new_obs_length
      :annotation: = 200

      

   .. method:: reset_x(self, x, copy=True)

      reset self.__x private attribute

      :param x: the new numeric data
      :type x: `numpy.ndarray`
      :param copy: flag to make a copy of 'x'. Defaule is True
      :type copy: `bool`


   .. method:: __str__(self)

      overload of object.__str__()

      :returns: string representation
      :rtype: `str`


   .. method:: __getitem__(self, item)

      a very crude overload of object.__getitem__().

      :param item: something that can be used as an index
      :type item: `object`

      :returns: an object that is a sub-matrix of `Matrix`
      :rtype: `Matrix`


   .. method:: __pow__(self, power)

      overload of numpy.ndarray.__pow__() operator

      :param power: interpreted as follows: -1 = inverse of self,
                    -0.5 = sqrt of inverse of self,
                    0.5 = sqrt of self. All other positive
                    ints = elementwise self raised to power
      :type power: `float`

      :returns: a new Matrix object
      :rtype: `Matrix`


   .. method:: __sub__(self, other)

      numpy.ndarray.__sub__() overload.  Tries to speedup by
       checking for scalars of diagonal matrices on either side of operator

      :param other: (`int`,`float`,`numpy.ndarray`,`Matrix`): the thing to subtract

      :returns: the result of subtraction
      :rtype: `Matrix`

      .. note::

         if `Matrix` and other (if applicable) have `autoalign` set to `True`,
         both `Matrix` and `other` are aligned based on row and column names.
         If names are not common between the two, this may result in a smaller
         returned `Matrix`


   .. method:: __add__(self, other)

      Overload of numpy.ndarray.__add__().  Tries to speedup by checking for
          scalars of diagonal matrices on either side of operator

      :param other: (`int`,`float`,`numpy.ndarray`,`Matrix`): the thing to add

      :returns: the result of addition
      :rtype: `Matrix`

      .. note::

         if `Matrix` and other (if applicable) have `autoalign` set to `True`,
         both `Matrix` and `other` are aligned based on row and column names.
         If names are not common between the two, this may result in a smaller
         returned `Matrix`


   .. method:: hadamard_product(self, other)

      Overload of numpy.ndarray.__mult__(): element-wise multiplication.
      Tries to speedup by checking for scalars of diagonal matrices on
      either side of operator

      :param other: (`int`,`float`,`numpy.ndarray`,`Matrix`): the thing to multiply

      :returns: the result of multiplication
      :rtype: `Matrix`

      .. note::

         if `Matrix` and other (if applicable) have `autoalign` set to `True`,
         both `Matrix` and `other` are aligned based on row and column names.
         If names are not common between the two, this may result in a smaller
         returned `Matrix`


   .. method:: __mul__(self, other)

      Dot product multiplication overload.  Tries to speedup by
      checking for scalars or diagonal matrices on either side of operator

      :param other: (`int`,`float`,`numpy.ndarray`,`Matrix`): the thing to dot product

      :returns: the result of dot product
      :rtype: `Matrix`

      .. note::

         if `Matrix` and other (if applicable) have `autoalign` set to `True`,
         both `Matrix` and `other` are aligned based on row and column names.
         If names are not common between the two, this may result in a smaller
         returned `Matrix`


   .. method:: __rmul__(self, other)

      Reverse order Dot product multiplication overload.

      :param other: (`int`,`float`,`numpy.ndarray`,`Matrix`): the thing to dot product

      :returns: the result of dot product
      :rtype: `Matrix`

      .. note::

         if `Matrix` and other (if applicable) have `autoalign` set to `True`,
         both `Matrix` and `other` are aligned based on row and column names.
         If names are not common between the two, this may result in a smaller
         returned `Matrix`


   .. method:: __set_svd(self)

      private method to set SVD components.

      Note: this should not be called directly


   .. method:: mult_isaligned(self, other)

      check if matrices are aligned for dot product multiplication

      :param other: the other matrix to check for alignment with
      :type other: `Matrix`

      :returns: True if aligned, False if not aligned
      :rtype: `bool`


   .. method:: element_isaligned(self, other)

      check if matrices are aligned for element-wise operations

      :param other: the other matrix to check for alignment with
      :type other: `Matrix`

      :returns: True if aligned, False if not aligned
      :rtype: `bool`


   .. method:: newx(self)
      :property:

      return a copy of `Matrix.x` attribute

      :returns: a copy `Matrix.x`
      :rtype: `numpy.ndarray`


   .. method:: x(self)
      :property:

      return a reference to `Matrix.x`

      :returns: reference to `Matrix.x`
      :rtype: `numpy.ndarray`


   .. method:: as_2d(self)
      :property:

      get a 2D numeric representation of `Matrix.x`.  If not `isdiagonal`, simply
      return reference to `Matrix.x`, otherwise, constructs and returns
      a 2D, diagonal ndarray

      :returns: numpy.ndarray
      :rtype: `numpy.ndarray`


   .. method:: to_2d(self)

      get a 2D `Matrix` representation of `Matrix`.  If not `Matrix.isdiagonal`, simply
              return a copy of `Matrix`, otherwise, constructs and returns a new `Matrix`
              instance that is stored as diagonal

      :returns: non-diagonal form of `Matrix`
      :rtype: `Martrix`


   .. method:: shape(self)
      :property:

      get the implied, 2D shape of `Matrix`

      :returns: length of 2 tuple
      :rtype: `int`


   .. method:: ncol(self)
      :property:

      length of second dimension

      :returns: number of columns
      :rtype: `int`


   .. method:: nrow(self)
      :property:

      length of first dimension

      :returns: number of rows
      :rtype: `int`


   .. method:: T(self)
      :property:

      wrapper function for `Matrix.transpose()` method

      :returns: transpose of `Matrix`
      :rtype: `Matrix`


   .. method:: transpose(self)
      :property:

      transpose operation of self

      :returns: transpose of `Matrix`
      :rtype: `Matrix`


   .. method:: inv(self)
      :property:

      inversion operation of `Matrix`

      :returns: inverse of `Matrix`
      :rtype: `Matrix`

      .. note:: uses `numpy.linalg.inv` for the inversion

      Example::

          mat = pyemu.Matrix.from_binary("my.jco")
          mat_inv = mat.inv
          mat_inv.to_binary("my_inv.jco")


   .. method:: get_maxsing_from_s(s, eigthresh=1e-05)
      :staticmethod:

      static method to work out the maxsing for a
      given singular spectrum

      :param s: 1-D array of singular values. This
                array should come from calling either `numpy.linalg.svd`
                or from the `pyemu.Matrix.s.x` attribute
      :type s: `numpy.ndarray`
      :param eigthresh: the ratio of smallest to largest
                        singular value to retain.  Since it is assumed that
                        `s` is sorted from largest to smallest, once a singular value
                        is reached that yields a ratio with the first (largest)
                        singular value, the index of this singular is returned.
      :type eigthresh: `float`

      :returns: the index of the singular value whos ratio with the
                first singular value is less than or equal to `eigthresh`
      :rtype: `int`


   .. method:: get_maxsing(self, eigthresh=1e-05)

      Get the number of singular components with a singular
      value ratio greater than or equal to eigthresh

       Args:
          eigthresh (`float`): the ratio of smallest to largest
              singular value to retain.  Since it is assumed that
              `s` is sorted from largest to smallest, once a singular value
              is reached that yields a ratio with the first (largest)
              singular value, the index of this singular is returned.

      :returns: the index of the singular value whos ratio with the
                first singular value is less than or equal to `eigthresh`
      :rtype: `int`

      .. note::

         this method calls the static method `Matrix.get_maxsing_from_s()`
         with `Matrix.s.x`


   .. method:: pseudo_inv_components(self, maxsing=None, eigthresh=1e-05, truncate=True)

      Get the (optionally) truncated SVD components

      :param maxsing: the number of singular components to use.  If None,
                      `maxsing` is calculated using `Matrix.get_maxsing()` and `eigthresh`
      :type maxsing: `int`, optional
      :param `eigthresh`: (`float`, optional): the ratio of largest to smallest singular
                          components to use for truncation.  Ignored if maxsing is not None.  Default is
                          1.0e-5
      :param truncate: flag to truncate components. If False, U, s, and V will be
                       zeroed out at locations greater than `maxsing` instead of truncated. Default is True
      :type truncate: `bool`

      :returns: tuple containing

                - **Matrix**: (optionally truncated) left singular vectors
                - **Matrix**: (optionally truncated) singular value matrix
                - **Matrix**: (optionally truncated) right singular vectors

      Example::

          mat = pyemu.Matrix.from_binary("my.jco")
          u,s,v = mat.pseudo_inv_components(maxsing=10)
          resolution_matrix = v * v.T
          resolution_matrix.to_ascii("resol.mat")


   .. method:: pseudo_inv(self, maxsing=None, eigthresh=1e-05)

      The pseudo inverse of self.  Formed using truncated singular
      value decomposition and `Matrix.pseudo_inv_components`

      :param maxsing: the number of singular components to use.  If None,
                      `maxsing` is calculated using `Matrix.get_maxsing()` and `eigthresh`
      :type maxsing: `int`, optional
      :param `eigthresh`: (`float`, optional): the ratio of largest to smallest singular
                          components to use for truncation.  Ignored if maxsing is not None.  Default is
                          1.0e-5

      :returns: the truncated-SVD pseudo inverse of `Matrix` (V_1 * s_1^-1 * U^T)
      :rtype: `Matrix`


   .. method:: sqrt(self)
      :property:

      element-wise square root operation

      :returns: element-wise square root of `Matrix`
      :rtype: `Matrix`

      .. note:: uses `numpy.sqrt`


   .. method:: full_s(self)
      :property:

      Get the full singular value matrix

      :returns: full singular value matrix.  Shape is `(max(Matrix.shape),max(Matrix.shape))`
                with zeros along the diagonal from `min(Matrix.shape)` to `max(Matrix.shape)`
      :rtype: `Matrix`


   .. method:: s(self)
      :property:

      the singular value (diagonal) Matrix

      :returns: singular value matrix.  shape is `(min(Matrix.shape),min(Matrix.shape))`
      :rtype: `Matrix`


   .. method:: u(self)
      :property:

      the left singular vector Matrix

      :returns: left singular vectors.  Shape is `(Matrix.shape[0], Matrix.shape[0])`
      :rtype: `Matrix`


   .. method:: v(self)
      :property:

      the right singular vector Matrix

      :returns: right singular vectors.  Shape is `(Matrix.shape[1], Matrix.shape[1])`
      :rtype: `Matrix`


   .. method:: zero2d(self)
      :property:

      get an 2D instance of self with all zeros

      :returns: `Matrix of zeros`
      :rtype: `Matrix`


   .. method:: find_rowcol_indices(names, row_names, col_names, axis=None)
      :staticmethod:

      fast(er) look of row and colum names indices

      :param names: list of names to look for in `row_names` and/or `col_names` names
      :type names: [`str`]
      :param row_names: list of row names
      :type row_names: [`str`]
      :param col_names: list of column names
      :type col_names: [`str`]
      :param axis: axis to search along.  If None, search both.
                   Default is `None`
      :type axis: `int`, optional

      :returns: array of (integer) index locations.  If `axis` is
                `None`, a 2 `numpy.ndarrays` of both row and column name indices is returned
      :rtype: `numpy.ndarray`


   .. method:: indices(self, names, axis=None)

      get the row and col indices of names. If axis is None, two ndarrays
              are returned, corresponding the indices of names for each axis

      :param names: list of names to look for in `row_names` and/or `col_names` names
      :type names: [`str`]
      :param row_names: list of row names
      :type row_names: [`str`]
      :param col_names: list of column names
      :type col_names: [`str`]
      :param axis: axis to search along.  If None, search both.
                   Default is `None`
      :type axis: `int`, optional

      :returns: array of (integer) index locations.  If `axis` is
                `None`, a 2 `numpy.ndarrays` of both row and column name indices is returned
      :rtype: `numpy.ndarray`

      .. note:: thin wrapper around `Matrix.find_rowcol_indices` static method


   .. method:: align(self, names, axis=None)

      reorder `Matrix` by names in place.  If axis is None, reorder both indices

      :param names: names in `Matrix.row_names` and\or `Matrix.col_names`
      :type names: ['str']
      :param axis: the axis to reorder. if None, reorder both axes
      :type axis: `int`, optional


   .. method:: get(self, row_names=None, col_names=None, drop=False)

      get a new `Matrix` instance ordered on row_names or col_names

      :param row_names: row_names for new Matrix.  If `None`,
                        all row_names are used.
      :type row_names: ['str'], optional
      :param col_names: col_names for new Matrix. If `None`,
                        all col_names are used.
      :type col_names: ['str'], optional
      :param drop: flag to remove row_names and/or col_names from this `Matrix`
      :type drop: `bool`

      :returns: a new `Matrix`
      :rtype: `Matrix`


   .. method:: copy(self)

      get a copy of `Matrix`

      :returns: copy of this `Matrix`
      :rtype: `Matrix`


   .. method:: drop(self, names, axis)

      drop elements from `Matrix` in place

      :param names: list of names to drop
      :type names: ['str']
      :param axis: the axis to drop from. must be in [0,1]
      :type axis: `int`


   .. method:: extract(self, row_names=None, col_names=None)

      wrapper method that `Matrix.gets()` then `Matrix.drops()` elements.
      one of row_names or col_names must be not None.

      :param row_names: row_names to extract.  If `None`,
                        all row_names are retained.
      :type row_names: ['str'], optional
      :param col_names: col_names to extract. If `None`,
                        all col_names are retained.
      :type col_names: ['str'], optional

      :returns: the extract sub-matrix defined by `row_names` and/or `col_names`
      :rtype: `Matrix`


   .. method:: get_diagonal_vector(self, col_name='diag')

      Get a new Matrix instance that is the diagonal of self.  The
      shape of the new matrix is (self.shape[0],1).  Self must be square

      :param col_name: the name of the single column in the new Matrix
      :type col_name: `str`

      :returns: vector-shaped `Matrix` instance of the diagonal of this `Matrix`
      :rtype: `Matrix`


   .. method:: to_coo(self, filename, droptol=None, chunk=None)

      write an extended PEST-format binary file.  The data format is
      [int,int,float] for i,j,value.  It is autodetected during
      the read with `Matrix.from_binary()`.

      :param filename: filename to save binary file
      :type filename: `str`
      :param droptol: absolute value tolerance to make values
                      smaller `droptol` than zero.  Default is None (no dropping)
      :type droptol: `float`
      :param chunk: number of elements to write in a single pass.
                    Default is `None`, which writes the entire numeric part of the
                    `Matrix` at once. This is faster but requires more memory.
      :type chunk: `int`


   .. method:: to_binary(self, filename, droptol=None, chunk=None)

      write a PEST-compatible binary file.  The format is the same
      as the format used to storage a PEST Jacobian matrix

      :param filename: filename to save binary file
      :type filename: `str`
      :param droptol: absolute value tolerance to make values
                      smaller `droptol` than zero.  Default is None (no dropping)
      :type droptol: `float`
      :param chunk: number of elements to write in a single pass.
                    Default is `None`, which writes the entire numeric part of the
                    `Matrix` at once. This is faster but requires more memory.
      :type chunk: `int`


   .. method:: from_binary(cls, filename)
      :classmethod:

      class method load from PEST-compatible binary file into a
      Matrix instance

      :param filename: filename to read
      :type filename: `str`

      :returns: `Matrix` loaded from binary file
      :rtype: `Matrix`

      Example::

          mat = pyemu.Matrix.from_binary("my.jco")
          cov = pyemi.Cov.from_binary("large_cov.jcb")


   .. method:: read_binary(filename)
      :staticmethod:

      static method to read PEST-format binary files

      :param filename: filename to read
      :type filename: `str`

      :returns: tuple containing

                - **numpy.ndarray**: the numeric values in the file
                - **['str']**: list of row names
                - **[`str`]**: list of col_names


   .. method:: from_fortranfile(filename)
      :staticmethod:

      a binary load method to accommodate one of the many
          bizarre fortran binary writing formats

      :param filename: name of the binary matrix file
      :type filename: `str`

      :returns: tuple containing

                - **numpy.ndarray**: the numeric values in the file
                - **['str']**: list of row names
                - **[`str`]**: list of col_names


   .. method:: to_ascii(self, filename, icode=2)

      write a PEST-compatible ASCII Matrix/vector file

      :param filename: filename to write to
      :type filename: `str`

      icode (`int`, optional): PEST-style info code for matrix style.
          Default is 2


   .. method:: from_ascii(cls, filename)
      :classmethod:

      load a PEST-compatible ASCII matrix/vector file into a
      `Matrix` instance

      :param filename: name of the file to read
      :type filename: `str`

      :returns: `Matrix` loaded from ASCII file
      :rtype: `Matrix`

      Example::

          mat = pyemu.Matrix.from_ascii("my.mat")
          cov = pyemi.Cov.from_ascii("my.cov")


   .. method:: read_ascii(filename)
      :staticmethod:

      read a PEST-compatible ASCII matrix/vector file

      :param filename: file to read from
      :type filename: `str`

      :returns: tuple containing

                - **numpy.ndarray**: numeric values
                - **['str']**: list of row names
                - **[`str`]**: list of column names
                - **bool**: diagonal flag


   .. method:: df(self)

      wrapper of Matrix.to_dataframe()


   .. method:: from_dataframe(cls, df)
      :classmethod:

      class method to create a new `Matrix` instance from a
       `pandas.DataFrame`

      :param df: dataframe
      :type df: `pandas.DataFrame`

      :returns: `Matrix` instance derived from `df`.
      :rtype: `Matrix`

      Example::

          df = pd.read_csv("my.csv")
          mat = pyemu.Matrix.from_dataframe(df)


   .. method:: from_names(cls, row_names, col_names, isdiagonal=False, autoalign=True, random=False)
      :classmethod:

      class method to create a new Matrix instance from
      row names and column names, filled with trash

      :param row_names: row names for the new `Matrix`
      :type row_names: ['str']
      :param col_names: col_names for the new matrix
      :type col_names: ['str']
      :param isdiagonal: flag for diagonal matrix. Default is False
      :type isdiagonal: `bool`, optional
      :param autoalign: flag for autoaligning new matrix
                        during linear algebra calcs. Default is True
      :type autoalign: `bool`, optional
      :param random: flag for contents of the trash matrix.
                     If True, fill with random numbers, if False, fill with zeros
                     Default is False
      :type random: `bool`

      :returns: the new Matrix instance
      :rtype: `Matrix`


   .. method:: to_dataframe(self)

      return a pandas.DataFrame representation of `Matrix`

      :returns: a dataframe derived from `Matrix`
      :rtype: `pandas.DataFrame`


   .. method:: extend(self, other)

      extend `Matrix` with the elements of other.

      Args:
      other (`Matrix`):  the Matrix to extend self by
      inplace (`bool`): inplace = True not implemented

      :returns: new, extended `Matrix`
      :rtype: `Matrix`



.. py:class:: Pst(filename, load=True, resfile=None)

   Bases: :class:`object`

   All things PEST(++) control file

   :param filename: the name of the control file
   :type filename: `str`
   :param load: flag to load the control file. Default is True
   :type load: `bool`, optional
   :param resfile: corresponding residual file.  If `None`, a residual file
                   with the control file base name is sought.  Default is `None`
   :type resfile: `str`, optional

   .. note::

      This class is the primary mechanism for dealing with PEST control files.  Support is provided
      for constructing new control files as well as manipulating existing control files.

   Example::

       pst = pyemu.Pst("my.pst")
       pst.control_data.noptmax = -1
       pst.write("my_new.pst")

   .. attribute:: parameter_data
      

      '* parameter data' information.  Columns are
      standard PEST variable names

      Example::

          pst.parameter_data.loc[:,"partrans"] = "log"
          pst.parameter_data.loc[:,"parubnd"] = 10.0

      :type: pandas.DataFrame


   .. attribute:: observation_data
      

      '* observation data' information.  Columns are standard PEST
      variable names

      Example::

          pst.observation_data.loc[:,"weight"] = 1.0
          pst.observation_data.loc[:,"obgnme"] = "obs_group"

      :type: pandas.DataFrame


   .. attribute:: prior_information
      

      '* prior information' data.  Columns are standard PEST
      variable names

      :type: pandas.DataFrame


   .. attribute:: control_data
      

      '* control data' information.
      Access with standard PEST variable names

      Example::

          pst.control_data.noptmax = 2
          pst.control_data.pestmode = "estimation"

      :type: pyemu.pst.pst_controldata.ControlData


   .. attribute:: svd_data
      

      '* singular value decomposition' section information.
      Access with standard PEST variable names

      Example::

          pst.svd_data.maxsing = 100

      :type: pyemu.pst.pst_controldata.SvdData


   .. attribute:: reg_data
      

      '* regularization' section information.
      Access with standard PEST variable names.

      Example::

          pst.reg_data.phimlim = 1.00 #yeah right!

      :type: pyemu.pst.pst_controldata.RegData


   .. method:: __setattr__(self, key, value)

      Implement setattr(self, name, value).


   .. method:: from_par_obs_names(cls, par_names=['par1'], obs_names=['obs1'])
      :classmethod:

      construct a shell `Pst` instance from parameter and observation names

      :param par_names: list of parameter names.  Default is [`par1`]
      :type par_names: [`str`]
      :param obs_names: list of observation names.  Default is [`obs1`]
      :type obs_names: [`str`]

      .. note::

         While this method works, it does not make template or instruction files.
         Users are encouraged to use `Pst.from_io_files()` for more usefulness

      Example::

          par_names = ["par1","par2"]
          obs_names = ["obs1","obs2"]
          pst = pyemu.Pst.from_par_obs_names(par_names,obs_names)


   .. method:: phi(self)
      :property:

      get the weighted total objective function.

      :returns: sum of squared residuals
      :rtype: `float`

      .. note:: Requires `Pst.res` (the residuals file) to be available


   .. method:: phi_components(self)
      :property:

      get the individual components of the total objective function

      :returns: dictionary of observation group, contribution to total phi
      :rtype: `dict`

      .. note:: Requires `Pst.res` (the residuals file) to be available


   .. method:: phi_components_normalized(self)
      :property:

      get the individual components of the total objective function
          normalized to the total PHI being 1.0

      :returns: dictionary of observation group,
                normalized contribution to total phi
      :rtype: `dict`

      .. note:: Requires `Pst.res` (the residuals file) to be available


   .. method:: set_res(self, res)

      reset the private `Pst.res` attribute.

      :param res: (`pandas.DataFrame` or `str`): something to use as Pst.res attribute.
                  If `res` is `str`, a dataframe is read from file `res`


   .. method:: res(self)
      :property:

      get the residuals dataframe attribute

      :returns: a dataframe containing the
                residuals information.
      :rtype: `pandas.DataFrame`

      .. note::

         if the Pst.__res attribute has not been loaded,
             this call loads the res dataframe from a file


   .. method:: nprior(self)
      :property:

      number of prior information equations

      :returns: the number of prior info equations
      :rtype: `int`


   .. method:: nnz_obs(self)
      :property:

      get the number of non-zero weighted observations

      :returns: the number of non-zeros weighted observations
      :rtype: `int`


   .. method:: nobs(self)
      :property:

      get the number of observations

      :returns: the number of observations
      :rtype: `int`


   .. method:: npar_adj(self)
      :property:

      get the number of adjustable parameters (not fixed or tied)

      :returns: the number of adjustable parameters
      :rtype: `int`


   .. method:: npar(self)
      :property:

      get number of parameters

      :returns: the number of parameters
      :rtype: `int`


   .. method:: forecast_names(self)
      :property:

      get the forecast names from the pestpp options (if any).
      Returns None if no forecasts are named

      :returns: a list of forecast names.
      :rtype: [`str`]


   .. method:: obs_groups(self)
      :property:

      get the observation groups

      :returns: a list of unique observation groups
      :rtype: [`str`]


   .. method:: nnz_obs_groups(self)
      :property:

      get the observation groups that contain at least one non-zero weighted
       observation

      :returns: a list of observation groups that contain at
                least one non-zero weighted observation
      :rtype: [`str`]


   .. method:: adj_par_groups(self)
      :property:

      get the parameter groups with atleast one adjustable parameter

      :returns: a list of parameter groups with
                at least one adjustable parameter
      :rtype: [`str`]


   .. method:: par_groups(self)
      :property:

      get the parameter groups

      :returns: a list of parameter groups
      :rtype: [`str`]


   .. method:: prior_groups(self)
      :property:

      get the prior info groups

      :returns: a list of prior information groups
      :rtype: [`str`]


   .. method:: prior_names(self)
      :property:

      get the prior information names

      :returns: a list of prior information names
      :rtype: [`str`]


   .. method:: par_names(self)
      :property:

      get the parameter names

      :returns: a list of parameter names
      :rtype: [`str`]


   .. method:: adj_par_names(self)
      :property:

      get the adjustable (not fixed or tied) parameter names

      :returns: list of adjustable (not fixed or tied)
                parameter names
      :rtype: [`str`]


   .. method:: obs_names(self)
      :property:

      get the observation names

      :returns: a list of observation names
      :rtype: [`str`]


   .. method:: nnz_obs_names(self)
      :property:

      get the non-zero weight observation names

      :returns: a list of non-zero weighted observation names
      :rtype: [`str`]


   .. method:: zero_weight_obs_names(self)
      :property:

      get the zero-weighted observation names

      :returns: a list of zero-weighted observation names
      :rtype: [`str`]


   .. method:: estimation(self)
      :property:

      check if the control_data.pestmode is set to estimation

      :returns: True if `control_data.pestmode` is estmation, False otherwise
      :rtype: `bool`


   .. method:: tied(self)
      :property:

      list of tied parameter names

      :returns: a dataframe of tied parameter information.
                Columns of `tied` are `parnme` and `partied`.  Returns `None` if
                no tied parameters are found.
      :rtype: `pandas.DataFrame`


   .. method:: _read_df(f, nrows, names, converters, defaults=None)
      :staticmethod:

      a private method to read part of an open file into a pandas.DataFrame.

      :param f: open file handle
      :type f: `file`
      :param nrows: number of rows to read
      :type nrows: `int`
      :param names: names to set the columns of the dataframe with
      :type names: [`str`]
      :param converters: dictionary of lambda functions to convert strings
                         to numerical format
      :type converters: `dict`
      :param defaults: dictionary of default values to assign columns.
                       Default is None
      :type defaults: `dict`

      :returns: dataframe of control file section info
      :rtype: `pandas.DataFrame`


   .. method:: _read_line_comments(self, f, forgive)


   .. method:: _read_section_comments(self, f, forgive)


   .. method:: _parse_external_line(line, pst_path='.')
      :staticmethod:


   .. method:: _parse_path_agnostic(filename)
      :staticmethod:


   .. method:: _cast_df_from_lines(section, lines, fieldnames, converters, defaults, alias_map={}, pst_path='.')
      :staticmethod:


   .. method:: _cast_prior_df_from_lines(self, section, lines, pst_path='.')


   .. method:: _load_version2(self, filename)

      load a version 2 control file


   .. method:: load(self, filename)

      entry point load the pest control file.

      :param filename: pst filename
      :type filename: `str`

      .. note:: This method is called from the `Pst` construtor unless the `load` arg is `False`.


   .. method:: _parse_pestpp_line(self, line)


   .. method:: _update_control_section(self)

      private method to synchronize the control section counters with the
      various parts of the control file.  This is usually called during the
      Pst.write() method.


   .. method:: rectify_pgroups(self)

      synchronize parameter groups section with the parameter data section

      .. note::

         This method is called during `Pst.write()` to make sure all parameter
         groups named in `* parameter data` are included.  This is so users
         don't have to manually keep this section up.  This method can also be
         called during control file modifications to see what parameter groups
         are present and prepare for modifying the default values in the `* parameter
         group` section

      Example::

          pst = pyemu.Pst("my.pst")
          pst.parameter_data.loc["par1","pargp"] = "new_group"
          pst.rectify_groups()
          pst.parameter_groups.loc["new_group","derinc"] = 1.0



   .. method:: _parse_pi_par_names(self)

      private method to get the parameter names from prior information
      equations.  Sets a 'names' column in Pst.prior_information that is a list
      of parameter names



   .. method:: add_pi_equation(self, par_names, pilbl=None, rhs=0.0, weight=1.0, obs_group='pi_obgnme', coef_dict={})

      a helper to construct a new prior information equation.

      :param par_names: parameter names in the equation
      :type par_names: [`str`]
      :param pilbl: name to assign the prior information equation.  If None,
                    a generic equation name is formed. Default is None
      :type pilbl: `str`
      :param rhs: the right-hand side of the pi equation
      :type rhs: `float`
      :param weight: the weight of the equation
      :type weight: `float`
      :param obs_group: the observation group for the equation. Default is 'pi_obgnme'
      :type obs_group: `str`
      :param coef_dict: a dictionary of parameter name, coefficient pairs to assign
                        leading coefficients for one or more parameters in the equation.
                        If a parameter is not listed, 1.0 is used for its coefficients.
                        Default is {}
      :type coef_dict: `dict`


   .. method:: rectify_pi(self)

      rectify the prior information equation with the current state of the
      parameter_data dataframe.


      .. note::

         Equations that list fixed, tied or missing parameters
         are removed completely even if adjustable parameters are also
         listed in the equation. This method is called during Pst.write()


   .. method:: _write_df(self, name, f, df, formatters, columns)


   .. method:: sanity_checks(self)

      some basic check for strangeness

      .. note::

         checks for duplicate names, atleast 1 adjustable parameter
         and at least 1 non-zero-weighted observation


   .. method:: _write_version2(self, new_filename, use_pst_path=True, pst_rel_path='.')


   .. method:: write(self, new_filename, version=1)

      main entry point to write a pest control file.

      :param new_filename: name of the new pest control file
      :type new_filename: `str`
      :param version: flag for which version of control file to write (must be 1 or 2).
                      if None, uses Pst._version, which set in the constructor and modified
                      during the load
      :type version: `int`

      Example::

          pst = pyemu.Pst("my.pst")
          pst.parrep("my.par")
          pst.write(my_new.pst")


   .. method:: _write_version1(self, new_filename)

      write a version 1 pest control file





   .. method:: bounds_report(self, iterations=None)

      report how many parameters are at bounds. If ensemble, the base enbsemble member is evaluated

      :param iterations: a list of iterations for which a bounds report is requested
                         If None, all iterations for which `par` files are located are reported. Default
                         is None
      :type iterations: [`int`]

      :returns:

                a pandas DataFrame object with rows being parameter groups and columns
                    <iter>_num_at_ub, <iter>_num_at_lb, and <iter>_total_at_bounds
                    row 0 is total at bounds, subsequent rows correspond with groups
      :rtype: `df`

      .. rubric:: Example

      pst = pyemu.Pst("my.pst")
      df = pst.bound_report(iterations=[0,2,3])


   .. method:: get(self, par_names=None, obs_names=None)

      get a new pst object with subset of parameters and/or observations

      :param par_names: a list of parameter names to have in the new Pst instance.
                        If None, all parameters are in the new Pst instance. Default
                        is None
      :type par_names: [`str`]
      :param obs_names: a list of observation names to have in the new Pst instance.
                        If None, all observations are in teh new Pst instance. Default
                        is None
      :type obs_names: [`str`]

      :returns: a new Pst instance
      :rtype: `Pst`

      .. note::

         passing `par_names` as `None` and `obs_names` as `None` effectively
         generates a copy of the current `Pst`


   .. method:: parrep(self, parfile=None, enforce_bounds=True)

      replicates the pest parrep util. replaces the parval1 field in the
          parameter data section dataframe with values in a PEST parameter file

      :param parfile: parameter file to use.  If None, try to find and use
                      a parameter file that corresponds to the case name.
                      Default is None
      :type parfile: `str`, optional
      :param enforce_bounds: flag to enforce parameter bounds after parameter values are updated.
                             This is useful because PEST and PEST++ round the parameter values in the
                             par file, which may cause slight bound violations.  Default is `True`
      :type enforce_bounds: `bool`, optional


   .. method:: adjust_weights_discrepancy(self, resfile=None, original_ceiling=True, bygroups=False)

      adjusts the weights of each non-zero weight observation based
      on the residual in the pest residual file so each observations contribution
      to phi is 1.0 (e.g. Mozorov's discrepancy principal)

      :param resfile: residual file name.  If None, try to use a residual file
                      with the Pst case name.  Default is None
      :type resfile: `str`
      :param original_ceiling: flag to keep weights from increasing - this is
                               generally a good idea. Default is True
      :type original_ceiling: `bool`
      :param bygroups: flag to adjust weights by groups. If False, the weight
                       of each non-zero weighted observation is adjusted individually. If True,
                       intergroup weighting is preserved (the contribution to each group is used)
                       but this may result in some strangeness if some observations in a group have
                       a really low phi already.
      :type bygroups: `bool`

      Example::

          pst = pyemu.Pst("my.pst")
          print(pst.phi) #assumes "my.res" is colocated with "my.pst"
          pst.adjust_weights_discrepancy()
          print(pst.phi) # phi should equal number of non-zero observations


   .. method:: _adjust_weights_by_phi_components(self, components, original_ceiling)

      private method that resets the weights of observations by group to account for
      residual phi components.

      :param components: a dictionary of obs group:phi contribution pairs
      :type components: `dict`
      :param original_ceiling: flag to keep weights from increasing.
      :type original_ceiling: `bool`


   .. method:: __reset_weights(self, target_phis, res_idxs, obs_idxs)

      private method to reset weights based on target phi values
      for each group.  This method should not be called directly

      :param target_phis: target phi contribution for groups to reweight
      :type target_phis: `dict`
      :param res_idxs: the index positions of each group of interest
                       in the res dataframe
      :type res_idxs: `dict`
      :param obs_idxs: the index positions of each group of interest
                       in the observation data dataframe
      :type obs_idxs: `dict`


   .. method:: _adjust_weights_by_list(self, obslist, weight)

      a private method to reset the weight for a list of observation names.  Supports the
      data worth analyses in pyemu.Schur class.  This method only adjusts
      observation weights in the current weight is nonzero.  User beware!

      :param obslist: list of observation names
      :type obslist: [`str`]
      :param weight: new weight to assign
      :type weight: `float`


   .. method:: adjust_weights(self, obs_dict=None, obsgrp_dict=None)

      reset the weights of observations or observation groups to contribute a specified
      amount to the composite objective function

      :param obs_dict: dictionary of observation name,new contribution pairs
      :type obs_dict: `dict`, optional
      :param obsgrp_dict: dictionary of obs group name,contribution pairs
      :type obsgrp_dict: `dict`, optional

      .. note::

         if all observations in a named obs group have zero weight, they will all be
         assigned a non-zero weight so that the request phi contribution
         can be met.  Similarly, any observations listed in obs_dict with zero
         weight will also be reset. User beware!

      Example::

          pst = pyemu.Pst("my.pst")

          # adjust a single observation
          pst.adjust_weights(obs_dict={"obs1":10})

          # adjust a single observation group
          pst.adjust_weights(obsgrp_dict={"group1":100.0})

          # make all non-zero weighted groups have a contribution of 100.0
          balanced_groups = {grp:100 for grp in pst.nnz_obs_groups}
          pst.adjust_weights(obsgrp_dict=balanced_groups)


   .. method:: proportional_weights(self, fraction_stdev=1.0, wmax=100.0, leave_zero=True)

      setup  weights inversely proportional to the observation value

      :param fraction_stdev: the fraction portion of the observation
                             val to treat as the standard deviation.  set to 1.0 for
                             inversely proportional.  Default is 1.0
      :type fraction_stdev: `float`, optional
      :param wmax: maximum weight to allow.  Default is 100.0
      :type wmax: `float`, optional
      :param leave_zero: flag to leave existing zero weights.
                         Default is True
      :type leave_zero: `bool`, optional


   .. method:: calculate_pertubations(self)

      experimental method to calculate finite difference parameter
      pertubations.

      .. note::

         The pertubation values are added to the
         `Pst.parameter_data` attribute - user beware!


   .. method:: build_increments(self)

      experimental method to calculate parameter increments for use
      in the finite difference pertubation calculations

      .. note:: user beware!


   .. method:: add_transform_columns(self)

      add transformed values to the `Pst.parameter_data` attribute

      .. note::

         adds `parval1_trans`, `parlbnd_trans` and `parubnd_trans` to
         `Pst.parameter_data`


   .. method:: enforce_bounds(self)

      enforce bounds violation

      .. note:: cheap enforcement of simply bringing violators back in bounds


   .. method:: from_io_files(cls, tpl_files, in_files, ins_files, out_files, pst_filename=None, pst_path=None)
      :classmethod:

      create a Pst instance from model interface files.

      :param tpl_files: list of template file names
      :type tpl_files: [`str`]
      :param in_files: list of model input file names (pairs with template files)
      :type in_files: [`str`]
      :param ins_files: list of instruction file names
      :type ins_files: [`str`]
      :param out_files: list of model output file names (pairs with instruction files)
      :type out_files: [`str`]
      :param pst_filename: name of control file to write.  If None, no file is written.
                           Default is None
      :type pst_filename: `str`
      :param pst_path: the path from the control file to the IO files.  For example, if the
                       control will be in the same directory as the IO files, then `pst_path` should be '.'.
                       Default is None, which doesnt do any path manipulation on the I/O file names
      :type pst_path: 'str'

      :returns: new control file instance with parameter and observation names
                found in `tpl_files` and `ins_files`, repsectively.
      :rtype: `Pst`

      .. note::

         calls `pyemu.helpers.pst_from_io_files()`
         
         Assigns generic values for parameter info.  Tries to use INSCHEK
         to set somewhat meaningful observation values
         
         all file paths are relatively to where python is running.

      Example::

          tpl_files = ["my.tpl"]
          in_files = ["my.in"]
          ins_files = ["my.ins"]
          out_files = ["my.out"]
          pst = pyemu.Pst.from_io_files(tpl_files,in_files,ins_files,out_files)
          pst.control_data.noptmax = 0
          pst.write("my.pst)




   .. method:: add_parameters(self, template_file, in_file=None, pst_path=None)

      add new parameters to an existing control file

      :param template_file: template file with (possibly) some new parameters
      :type template_file: `str`
      :param in_file: model input file. If None, template_file.replace('.tpl','') is used.
                      Default is None.
      :type in_file: `str`
      :param pst_path: the path to append to the template_file and in_file in the control file.  If
                       not None, then any existing path in front of the template or in file is split off
                       and pst_path is prepended.  If python is being run in a directory other than where the control
                       file will reside, it is useful to pass `pst_path` as `.`.  Default is None
      :type pst_path: `str`

      :returns: the data for the new parameters that were added.
                If no new parameters are in the new template file, returns None
      :rtype: `pandas.DataFrame`

      .. note:: populates the new parameter information with default values

      Example::

          pst = pyemu.Pst(os.path.join("template","my.pst"))
          pst.add_parameters(os.path.join("template","new_pars.dat.tpl",pst_path=".")
          pst.write(os.path.join("template","my_new.pst")


   .. method:: add_observations(self, ins_file, out_file=None, pst_path=None, inschek=True)

      add new observations to a control file

      :param ins_file: instruction file with exclusively new observation names
      :type ins_file: `str`
      :param out_file: model output file.  If None, then ins_file.replace(".ins","") is used.
                       Default is None
      :type out_file: `str`
      :param pst_path: the path to append to the instruction file and out file in the control file.  If
                       not None, then any existing path in front of the template or in file is split off
                       and pst_path is prepended.  If python is being run in a directory other than where the control
                       file will reside, it is useful to pass `pst_path` as `.`. Default is None
      :type pst_path: `str`
      :param inschek: flag to try to process the existing output file using the `pyemu.InstructionFile`
                      class.  If successful, processed outputs are used as obsvals
      :type inschek: `bool`

      :returns: the data for the new observations that were added
      :rtype: `pandas.DataFrame`

      .. note:: populates the new observation information with default values

      Example::

          pst = pyemu.Pst(os.path.join("template", "my.pst"))
          pst.add_observations(os.path.join("template","new_obs.dat.ins"), pst_path=".")
          pst.write(os.path.join("template", "my_new.pst")


   .. method:: write_input_files(self, pst_path='.')

      writes model input files using template files and current `parval1` values.

      :param pst_path: the path to where control file and template files reside.
                       Default is '.'
      :type pst_path: `str`

      .. note::

         adds "parval1_trans" column to Pst.parameter_data that includes the
         effect of scale and offset

      Example::

          pst = pyemu.Pst("my.pst")

          # load final parameter values
          pst.parrep("my.par")

          # write new model input files with final parameter values
          pst.write_input_files()


   .. method:: process_output_files(self, pst_path='.')

      processing the model output files using the instruction files
      and existing model output files.

      :param pst_path: relative path from where python is running to
                       where the control file, instruction files and model output files
                       are located.  Default is "." (current python directory)
      :type pst_path: `str`

      :returns: model output values
      :rtype: `pandas.Series`

      .. note::

         requires a complete set of model input files at relative path
         from where python is running to `pst_path`


   .. method:: get_res_stats(self, nonzero=True)

      get some common residual stats by observation group.

      :param nonzero: calculate stats using only nonzero-weighted observations.  This may seem
                      obsvious to most users, but you never know....
      :type nonzero: `bool`

      :returns: a dataframe with columns for groups names and indices of statistic name.
      :rtype: `pd.DataFrame`

      .. note::

         Stats are derived from the current obsvals, weights and grouping in
         `Pst.observation_data` and the `modelled` values in `Pst.res`.  The
         key here is 'current' because if obsval, weights and/or groupings have
         changed in `Pst.observation_data` since the residuals file was generated
         then the current values for `obsval`, `weight` and `group` are used
         
         the normalized RMSE is normalized against the obsval range (max - min)


   .. method:: _stats_rss(df)
      :staticmethod:


   .. method:: _stats_mean(df)
      :staticmethod:


   .. method:: _stats_mae(df)
      :staticmethod:


   .. method:: _stats_rmse(df)
      :staticmethod:


   .. method:: _stats_nrmse(df)
      :staticmethod:


   .. method:: plot(self, kind=None, **kwargs)

      method to plot various parts of the control.  This is sweet as!

      :param kind: options are 'prior' (prior parameter histograms, '1to1' (line of equality
                   and sim vs res), 'obs_v_sim' (time series using datetime suffix), 'phi_pie'
                   (pie chart of phi components)
      :type kind: `str`
      :param kwargs: optional args for plots that are passed to pyemu plot helpers and ultimately
                     to matplotlib
      :type kwargs: `dict`

      .. note:: Depending on 'kind' argument, a multipage pdf is written

      Example::

          pst = pyemu.Pst("my.pst")
          pst.plot(kind="1to1") # requires Pst.res
          pst.plot(kind="prior")
          pst.plot(kind="phi_pie")



   .. method:: write_par_summary_table(self, filename=None, group_names=None, sigma_range=4.0)

      write a stand alone parameter summary latex table


      :param filename: latex filename. If None, use <case>.par.tex. If `filename` is "none", no table
                       is writtenDefault is None
      :type filename: `str`
      :param group_names: par group names : table names. For example {"w0":"well stress period 1"}.
                          Default is None
      :type group_names: `dict`
      :param sigma_range: number of standard deviations represented by parameter bounds.  Default
                          is 4.0, implying 95% confidence bounds
      :type sigma_range: `float`

      :returns: the summary parameter group dataframe
      :rtype: `pandas.DataFrame`

      Example::

          pst = pyemu.Pst("my.pst")
          pst.write_par_summary_table(filename="par.tex")


   .. method:: write_obs_summary_table(self, filename=None, group_names=None)

      write a stand alone observation summary latex table


      :param filename: latex filename. If `filename` is "none", no table is written.
                       If None, use <case>.par.tex. Default is None
      :type filename: `str`
      :param group_names: obs group names : table names. For example {"hds":"simulated groundwater level"}.
                          Default is None
      :type group_names: `dict`

      :returns: the summary observation group dataframe
      :rtype: `pandas.DataFrame`

      Example::

          pst = pyemu.Pst("my.pst")
          pst.write_obs_summary_table(filename="obs.tex")


   .. method:: _is_less_const(name)
      :staticmethod:


   .. method:: less_than_obs_constraints(self)
      :property:

      get the names of the observations that
      are listed as active less than inequality constraints.

      :returns: names of obseravtions that are non-zero weighted less
                than constraints (`obgnme` starts with 'l\_' or "less")
      :rtype: `pandas.Series`

      .. note:: Zero-weighted obs are skipped


   .. method:: less_than_pi_constraints(self)
      :property:

      get the names of the prior information eqs that
      are listed as active less than inequality constraints.

      :returns: names of prior information that are non-zero weighted
                less than constraints (`obgnme` starts with "l\_" or "less")
      :rtype: `pandas.Series`

      .. note:: Zero-weighted pi are skipped


   .. method:: _is_greater_const(name)
      :staticmethod:


   .. method:: greater_than_obs_constraints(self)
      :property:

      get the names of the observations that
      are listed as active greater than inequality constraints.

      :returns: names obseravtions that are non-zero weighted
                greater than constraints (`obgnme` startsiwth "g\_" or "greater")
      :rtype: `pandas.Series`

      .. note:: Zero-weighted obs are skipped


   .. method:: greater_than_pi_constraints(self)
      :property:

      get the names of the prior information eqs that
      are listed as active greater than inequality constraints.

      :returns: `pandas.Series` names of prior information that are non-zero weighted
                greater than constraints (`obgnme` startsiwth "g\_" or "greater")

      .. note:: Zero-weighted pi are skipped


   .. method:: get_par_change_limits(self)

      calculate the various parameter change limits used in pest.


      :returns: a copy of `Pst.parameter_data`
                with columns for relative and factor change limits
      :rtype: `pandas.DataFrame`

      .. note::

         does not yet support absolute parameter change limits!
         
         Works in control file values space (not log transformed space).  Also
         adds columns for effective upper and lower which account for par bounds and the
         value of parchglim


   .. method:: get_adj_pars_at_bounds(self, frac_tol=0.01)

      get list of adjustable parameter at/near bounds

      :param frac_tol: fractional tolerance of distance to bound.  For upper bound,
                       the value `parubnd * (1-frac_tol)` is used, lower bound uses `parlbnd * (1.0 + frac_tol)`
      :type frac_tol: 'float`

      :returns:

                - **[`str`]**: list of parameters at/near lower bound
                - **[`str`]**: list of parameters at/near upper bound
      :rtype: tuple containing


   .. method:: try_parse_name_metadata(self)

      try to add meta data columns to parameter and observation data based on
      item names.  Used with the PstFrom process.

      Note: metadata is identified in key-value pairs that are separated by a colon.
          each key-value pair is separated from others by underscore



