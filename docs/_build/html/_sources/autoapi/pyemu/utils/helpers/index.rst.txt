:mod:`pyemu.utils.helpers`
==========================

.. py:module:: pyemu.utils.helpers

.. autoapi-nested-parse::

   High-level functions to help perform complex tasks



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pyemu.utils.helpers.PstFromFlopyModel
   pyemu.utils.helpers.SpatialReference



Functions
~~~~~~~~~

.. autoapisummary::

   pyemu.utils.helpers.geostatistical_draws
   pyemu.utils.helpers.geostatistical_prior_builder
   pyemu.utils.helpers._rmse
   pyemu.utils.helpers.calc_observation_ensemble_quantiles
   pyemu.utils.helpers.calc_rmse_ensemble
   pyemu.utils.helpers._condition_on_par_knowledge
   pyemu.utils.helpers.kl_setup
   pyemu.utils.helpers._eigen_basis_to_factor_file
   pyemu.utils.helpers.kl_apply
   pyemu.utils.helpers.zero_order_tikhonov
   pyemu.utils.helpers._regweight_from_parbound
   pyemu.utils.helpers.first_order_pearson_tikhonov
   pyemu.utils.helpers.simple_tpl_from_pars
   pyemu.utils.helpers.simple_ins_from_obs
   pyemu.utils.helpers.pst_from_parnames_obsnames
   pyemu.utils.helpers.read_pestpp_runstorage
   pyemu.utils.helpers.jco_from_pestpp_runstorage
   pyemu.utils.helpers.parse_dir_for_io_files
   pyemu.utils.helpers.pst_from_io_files
   pyemu.utils.helpers.apply_list_and_array_pars
   pyemu.utils.helpers._process_chunk_fac2real
   pyemu.utils.helpers._process_chunk_model_files
   pyemu.utils.helpers._process_model_file
   pyemu.utils.helpers.apply_array_pars
   pyemu.utils.helpers.apply_list_pars
   pyemu.utils.helpers.apply_genericlist_pars
   pyemu.utils.helpers.write_const_tpl
   pyemu.utils.helpers.write_grid_tpl
   pyemu.utils.helpers.write_zone_tpl
   pyemu.utils.helpers.build_jac_test_csv
   pyemu.utils.helpers._write_df_tpl
   pyemu.utils.helpers.setup_fake_forward_run
   pyemu.utils.helpers.setup_temporal_diff_obs
   pyemu.utils.helpers.apply_temporal_diff_obs
   pyemu.utils.helpers.get_maha_obs_summary
   pyemu.utils.helpers._l2_maha_worker


.. data:: max_colwidth
   :annotation: = 100

   

.. function:: geostatistical_draws(pst, struct_dict, num_reals=100, sigma_range=4, verbose=True, scale_offset=True)

   construct a parameter ensemble from a prior covariance matrix
   implied by geostatistical structure(s) and parameter bounds.

   :param pst: a control file (or the name of control file).  The
               parameter bounds in `pst` are used to define the variance of each
               parameter group.
   :type pst: `pyemu.Pst`
   :param struct_dict: a dict of GeoStruct (or structure file), and list of
                       pilot point template files pairs. If the values in the dict are
                       `pd.DataFrames`, then they must have an 'x','y', and 'parnme' column.
                       If the filename ends in '.csv', then a pd.DataFrame is loaded,
                       otherwise a pilot points file is loaded.
   :type struct_dict: `dict`
   :param num_reals: number of realizations to draw.  Default is 100
   :type num_reals: `int`, optional
   :param sigma_range: a float representing the number of standard deviations
                       implied by parameter bounds. Default is 4.0, which implies 95% confidence parameter bounds.
   :type sigma_range: `float`
   :param verbose: flag to control output to stdout.  Default is True.
                   flag for stdout.
   :type verbose: `bool`, optional
   :param scale_offset: flag to apply scale and offset to parameter bounds
                        when calculating variances - this is passed through to `pyemu.Cov.from_parameter_data()`.
                        Default is True.
   :type scale_offset: `bool`,optional

   Returns
       `pyemu.ParameterEnsemble`: the realized parameter ensemble.

   .. note::

      parameters are realized by parameter group.  The variance of each
      parameter group is used to scale the resulting geostatistical
      covariance matrix Therefore, the sill of the geostatistical structures
      in `struct_dict` should be 1.0

   Example::

       pst = pyemu.Pst("my.pst")
       sd = {"struct.dat":["hkpp.dat.tpl","vka.dat.tpl"]}
       pe = pyemu.helpers.geostatistical_draws(pst,struct_dict=sd}
       pe.to_csv("my_pe.csv")



.. function:: geostatistical_prior_builder(pst, struct_dict, sigma_range=4, verbose=False, scale_offset=False)

   construct a full prior covariance matrix using geostastical structures
   and parameter bounds information.

   :param pst: a control file instance (or the name of control file)
   :type pst: `pyemu.Pst`
   :param struct_dict: a dict of GeoStruct (or structure file), and list of
                       pilot point template files pairs. If the values in the dict are
                       `pd.DataFrames`, then they must have an 'x','y', and 'parnme' column.
                       If the filename ends in '.csv', then a pd.DataFrame is loaded,
                       otherwise a pilot points file is loaded.
   :type struct_dict: `dict`
   :param sigma_range: a float representing the number of standard deviations
                       implied by parameter bounds. Default is 4.0, which implies 95% confidence parameter bounds.
   :type sigma_range: `float`
   :param verbose: flag to control output to stdout.  Default is True.
                   flag for stdout.
   :type verbose: `bool`, optional
   :param scale_offset: a flag to apply scale and offset to parameter upper and lower bounds
                        before applying log transform.  Passed to pyemu.Cov.from_parameter_data().  Default
                        is False
   :type scale_offset: `bool`

   :returns: a covariance matrix that includes all adjustable parameters in the control
             file.
   :rtype: `pyemu.Cov`

   .. note::

      The covariance of parameters associated with geostatistical structures is defined
      as a mixture of GeoStruct and bounds.  That is, the GeoStruct is used to construct a
      pyemu.Cov, then the entire pyemu.Cov is scaled by the uncertainty implied by the bounds and
      sigma_range. Most users will want to sill of the geostruct to sum to 1.0 so that the resulting
      covariance matrices have variance proportional to the parameter bounds. Sounds complicated...

   Example::

       pst = pyemu.Pst("my.pst")
       sd = {"struct.dat":["hkpp.dat.tpl","vka.dat.tpl"]}
       cov = pyemu.helpers.geostatistical_draws(pst,struct_dict=sd}
       cov.to_binary("prior.jcb")


.. function:: _rmse(v1, v2)

   return root mean squared error between v1 and v2

   :param v1: one vector
   :type v1: iterable
   :param v2: another vector
   :type v2: iterable

   :returns: root mean squared error of v1,v2
   :rtype: scalar


.. function:: calc_observation_ensemble_quantiles(ens, pst, quantiles, subset_obsnames=None, subset_obsgroups=None)

   Given an observation ensemble, and requested quantiles, this function calculates the requested
      quantile point-by-point in the ensemble. This resulting set of values does not, however, correspond
      to a single realization in the ensemble. So, this function finds the minimum weighted squared
      distance to the quantile and labels it in the ensemble. Also indicates which realizations
      correspond to the selected quantiles.

   :param ens: DataFrame read from an observation
   :type ens: pandas DataFrame
   :param pst:
   :type pst: pyemy.Pst object
   :param quantiles: quantiles ranging from 0-1.0 for which results requested
   :type quantiles: iterable
   :param subset_obsnames: list of observation names to include in calculations
   :type subset_obsnames: iterable
   :param subset_obsgroups: list of observation groups to include in calculations
   :type subset_obsgroups: iterable

   :returns:

             same ens object that was input but with quantile realizations
                                 appended as new rows labelled with 'q_#' where '#' is the slected quantile
             quantile_idx (dictionary): dictionary with keys being quantiles and values being realizations
                                     corresponding to each realization
   :rtype: ens (pandas DataFrame)


.. function:: calc_rmse_ensemble(ens, pst, bygroups=True, subset_realizations=None)

   Calculates RMSE (without weights) to quantify fit to observations for ensemble members

   :param ens: DataFrame read from an observation
   :type ens: pandas DataFrame
   :param pst:
   :type pst: pyemy.Pst object
   :param bygroups: Flag to summarize by groups or not. Defaults to True.
   :type bygroups: Bool
   :param subset_realizations: Subset of realizations for which
                               to report RMSE. Defaults to None which returns all realizations.
   :type subset_realizations: iterable, optional

   :returns: rows are realizations. Columns are groups. Content is RMSE
   :rtype: rmse (pandas DataFrame object)


.. function:: _condition_on_par_knowledge(cov, par_knowledge_dict)

   experimental function to include conditional prior information
   for one or more parameters in a full covariance matrix


.. function:: kl_setup(num_eig, sr, struct, prefixes, factors_file='kl_factors.dat', islog=True, basis_file=None, tpl_dir='.')

   setup a karhuenen-Loeve based parameterization for a given
   geostatistical structure.

   :param num_eig: the number of basis vectors to retain in the
                   reduced basis
   :type num_eig: `int`
   :param sr: a spatial reference instance
   :type sr: `flopy.reference.SpatialReference`
   :param struct: a PEST-style structure file.  Can also be a
                  `pyemu.geostats.Geostruct` instance.
   :type struct: `str`
   :param prefixes: a list of parameter prefixes to generate KL
                    parameterization for.
   :type prefixes: [`str`]
   :param factors_file: name of the PEST-style interpolation
                        factors file to write (can be processed with FAC2REAL).
                        Default is "kl_factors.dat".
   :type factors_file: `str`, optional
   :param islog: flag to indicate if the parameters are log transformed.
                 Default is True
   :type islog: `bool`, optional
   :param basis_file: the name of the PEST-style binary (e.g. jco)
                      file to write the reduced basis vectors to.  Default is None (not saved).
   :type basis_file: `str`, optional
   :param tpl_dir: the directory to write the resulting
                   template files to.  Default is "." (current directory).
   :type tpl_dir: `str`, optional

   :returns: a dataframe of parameter information.
   :rtype: `pandas.DataFrame`

   .. note:: This is the companion function to `helpers.apply_kl()`

   Example::

       m = flopy.modflow.Modflow.load("mymodel.nam")
       prefixes = ["hk","vka","ss"]
       df = pyemu.helpers.kl_setup(10,m.sr,"struct.dat",prefixes)


.. function:: _eigen_basis_to_factor_file(nrow, ncol, basis, factors_file, islog=True)


.. function:: kl_apply(par_file, basis_file, par_to_file_dict, arr_shape)

   Apply a KL parameterization transform from basis factors to model
   input arrays.

   :param par_file: the csv file to get factor values from.  Must contain
                    the following columns: "name", "new_val", "org_val"
   :type par_file: `str`
   :param basis_file: the PEST-style binary file that contains the reduced
                      basis
   :type basis_file: `str`
   :param par_to_file_dict: a mapping from KL parameter prefixes to array
                            file names.
   :type par_to_file_dict: `dict`
   :param arr_shape: a length 2 tuple of number of rows and columns
                     the resulting arrays should have.
   :type arr_shape: tuple
   :param Note: This is the companion function to kl_setup.
                This function should be called during the forward run


.. function:: zero_order_tikhonov(pst, parbounds=True, par_groups=None, reset=True)

   setup preferred-value regularization in a pest control file.

   :param pst: the control file instance
   :type pst: `pyemu.Pst`
   :param parbounds: flag to weight the new prior information
                     equations according to parameter bound width - approx the KL
                     transform. Default is True
   :type parbounds: `bool`, optional
   :param par_groups: a list of parameter groups to build PI equations for.
                      If None, all adjustable parameters are used. Default is None
   :type par_groups: `list`
   :param reset: a flag to remove any existing prior information equations
                 in the control file.  Default is True
   :type reset: `bool`

   Example::

       pst = pyemu.Pst("my.pst")
       pyemu.helpers.zero_order_tikhonov(pst)
       pst.write("my_reg.pst")


.. function:: _regweight_from_parbound(pst)

   sets regularization weights from parameter bounds
   which approximates the KL expansion.  Called by
   zero_order_tikhonov().


.. function:: first_order_pearson_tikhonov(pst, cov, reset=True, abs_drop_tol=0.001)

   setup preferred-difference regularization from a covariance matrix.


   :param pst: the PEST control file
   :type pst: `pyemu.Pst`
   :param cov: a covariance matrix instance with
               some or all of the parameters listed in `pst`.
   :type cov: `pyemu.Cov`
   :param reset: a flag to remove any existing prior information equations
                 in the control file.  Default is True
   :type reset: `bool`
   :param abs_drop_tol: tolerance to control how many pi equations
                        are written. If the absolute value of the Pearson CC is less than
                        abs_drop_tol, the prior information equation will not be included in
                        the control file.
   :type abs_drop_tol: `float`, optional

   .. note::

      The weights on the prior information equations are the Pearson
      correlation coefficients implied by covariance matrix.

   Example::

       pst = pyemu.Pst("my.pst")
       cov = pyemu.Cov.from_ascii("my.cov")
       pyemu.helpers.first_order_pearson_tikhonov(pst,cov)
       pst.write("my_reg.pst")


.. function:: simple_tpl_from_pars(parnames, tplfilename='model.input.tpl')

   Make a simple template file from a list of parameter names.

   :param parnames: list of parameter names to put in the
                    new template file
   :type parnames: [`str`]
   :param tplfilename: Name of the template file to create.  Default
                       is "model.input.tpl"
   :type tplfilename: `str`

   .. note:: writes a file `tplfilename` with each parameter name in `parnames` on a line


.. function:: simple_ins_from_obs(obsnames, insfilename='model.output.ins')

   write a simple instruction file that reads the values named
    in obsnames in order, one per line from a model output file

   :param obsnames: list of observation names to put in the
                    new instruction file
   :type obsnames: `str`
   :param insfilename: the name of the instruction file to
                       create. Default is "model.output.ins"
   :type insfilename: `str`

   .. note::

      writes a file `insfilename` with each observation read off
      of a single line


.. function:: pst_from_parnames_obsnames(parnames, obsnames, tplfilename='model.input.tpl', insfilename='model.output.ins')

   Creates a Pst object from a list of parameter names and a list of observation names.

   :param parnames: list of parameter names
   :type parnames: `str`
   :param obsnames: list of observation names
   :type obsnames: `str`
   :param tplfilename: template filename. Default is  "model.input.tpl"
   :type tplfilename: `str`
   :param insfilename: instruction filename. Default is "model.output.ins"
   :type insfilename: `str`

   :returns: the generic control file
   :rtype: `pyemu.Pst`


.. function:: read_pestpp_runstorage(filename, irun=0, with_metadata=False)

   read pars and obs from a specific run in a pest++ serialized
   run storage file into dataframes.

   :param filename: the name of the run storage file
   :type filename: `str`
   :param irun: the run id to process. If 'all', then all runs are
                read. Default is 0
   :type irun: `int`
   :param with_metadata: flag to return run stats and info txt as well
   :type with_metadata: `bool`

   :returns: tuple containing

             - **pandas.DataFrame**: parameter information
             - **pandas.DataFrame**: observation information
             - **pandas.DataFrame**: optionally run status and info txt.


.. function:: jco_from_pestpp_runstorage(rnj_filename, pst_filename)

   read pars and obs from a pest++ serialized run storage
   file (e.g., .rnj) and return jacobian matrix instance

   :param rnj_filename: the name of the run storage file
   :type rnj_filename: `str`
   :param pst_filename: the name of the pst file
   :type pst_filename: `str`

   .. note::

      This can then be passed to Jco.to_binary or Jco.to_coo, etc., to write jco
      file in a subsequent step to avoid memory resource issues associated
      with very large problems.

   :returns: a jacobian matrix constructed from the run results and
             pest control file information.
   :rtype: `pyemu.Jco`


.. function:: parse_dir_for_io_files(d, prepend_path=False)

   find template/input file pairs and instruction file/output file
   pairs by extension.

   :param d: directory to search for interface files
   :type d: `str`
   :param prepend_path: flag to prepend `d` to each file name.
                        Default is False
   :type prepend_path: `bool`, optional

   .. note::

      the return values from this function can be passed straight to
      `pyemu.Pst.from_io_files()` classmethod constructor. Assumes the
      template file names are <input_file>.tpl and instruction file names
      are <output_file>.ins.

   :returns: tuple containing

             - **[`str`]**: list of template files in d
             - **[`str`]**: list of input files in d
             - **[`str`]**: list of instruction files in d
             - **[`str`]**: list of output files in d


.. function:: pst_from_io_files(tpl_files, in_files, ins_files, out_files, pst_filename=None, pst_path=None)

   create a Pst instance from model interface files.

   :param tpl_files: list of template file names
   :type tpl_files: [`str`]
   :param in_files: list of model input file names (pairs with template files)
   :type in_files: [`str`]
   :param ins_files: list of instruction file names
   :type ins_files: [`str`]
   :param out_files: list of model output file names (pairs with instruction files)
   :type out_files: [`str`]
   :param pst_filename: name of control file to write.  If None, no file is written.
                        Default is None
   :type pst_filename: `str`
   :param pst_path: the path to append to the template_file and in_file in the control file.  If
                    not None, then any existing path in front of the template or in file is split off
                    and pst_path is prepended.  If python is being run in a directory other than where the control
                    file will reside, it is useful to pass `pst_path` as `.`.  Default is None
   :type pst_path: `str`

   :returns: new control file instance with parameter and observation names
             found in `tpl_files` and `ins_files`, repsectively.
   :rtype: `Pst`

   .. note::

      calls `pyemu.helpers.pst_from_io_files()`
      
      Assigns generic values for parameter info.  Tries to use INSCHEK
      to set somewhat meaningful observation values
      
      all file paths are relatively to where python is running.

   Example::

       tpl_files = ["my.tpl"]
       in_files = ["my.in"]
       ins_files = ["my.ins"]
       out_files = ["my.out"]
       pst = pyemu.Pst.from_io_files(tpl_files,in_files,ins_files,out_files)
       pst.control_data.noptmax = 0
       pst.write("my.pst)




.. data:: wildass_guess_par_bounds_dict
   

   

.. py:class:: PstFromFlopyModel(model, new_model_ws, org_model_ws=None, pp_props=[], const_props=[], temporal_bc_props=[], temporal_list_props=[], grid_props=[], grid_geostruct=None, pp_space=None, zone_props=[], pp_geostruct=None, par_bounds_dict=None, sfr_pars=False, temporal_sfr_pars=False, temporal_list_geostruct=None, remove_existing=False, k_zone_dict=None, mflist_waterbudget=True, mfhyd=True, hds_kperk=[], use_pp_zones=False, obssim_smp_pairs=None, external_tpl_in_pairs=None, external_ins_out_pairs=None, extra_pre_cmds=None, extra_model_cmds=None, extra_post_cmds=None, redirect_forward_output=True, tmp_files=None, model_exe_name=None, build_prior=True, sfr_obs=False, spatial_bc_props=[], spatial_list_props=[], spatial_list_geostruct=None, hfb_pars=False, kl_props=None, kl_num_eig=100, kl_geostruct=None)

   Bases: :class:`object`

   a monster helper class to setup a complex PEST interface around
   an existing MODFLOW-2005-family model.


   :param model: a loaded flopy model instance. If model is an str, it is treated as a
                 MODFLOW nam file (requires org_model_ws)
   :type model: `flopy.mbase`
   :param new_model_ws: a directory where the new version of MODFLOW input files and PEST(++)
                        files will be written
   :type new_model_ws: `str`
   :param org_model_ws: directory to existing MODFLOW model files.  Required if model argument
                        is an str.  Default is None
   :type org_model_ws: `str`
   :param pp_props: pilot point multiplier parameters for grid-based properties.
                    A nested list of grid-scale model properties to parameterize using
                    name, iterable pairs.  For 3D properties, the iterable is zero-based
                    layer indices.  For example, ["lpf.hk",[0,1,2,]] would setup pilot point multiplier
                    parameters for layer property file horizontal hydraulic conductivity for model
                    layers 1,2, and 3.  For time-varying properties (e.g. recharge), the
                    iterable is for zero-based stress period indices.  For example, ["rch.rech",[0,4,10,15]]
                    would setup pilot point multiplier parameters for recharge for stress
                    period 1,5,11,and 16.
   :type pp_props: [[`str`,[`int`]]]
   :param const_props: constant (uniform) multiplier parameters for grid-based properties.
                       A nested list of grid-scale model properties to parameterize using
                       name, iterable pairs.  For 3D properties, the iterable is zero-based
                       layer indices.  For example, ["lpf.hk",[0,1,2,]] would setup constant (uniform) multiplier
                       parameters for layer property file horizontal hydraulic conductivity for model
                       layers 1,2, and 3.  For time-varying properties (e.g. recharge), the
                       iterable is for zero-based stress period indices.  For example, ["rch.rech",[0,4,10,15]]
                       would setup constant (uniform) multiplier parameters for recharge for stress
                       period 1,5,11,and 16.
   :type const_props: [[`str`,[`int`]]]
   :param temporal_list_props: list-type input stress-period level multiplier parameters.
                               A nested list of list-type input elements to parameterize using
                               name, iterable pairs.  The iterable is zero-based stress-period indices.
                               For example, to setup multipliers for WEL flux and for RIV conductance,
                               temporal_list_props = [["wel.flux",[0,1,2]],["riv.cond",None]] would setup
                               multiplier parameters for well flux for stress periods 1,2 and 3 and
                               would setup one single river conductance multiplier parameter that is applied
                               to all stress periods
   :type temporal_list_props: [[`str`,[`int`]]]
   :param spatial_list_props: list-type input for spatial multiplier parameters.
                              A nested list of list-type elements to parameterize using
                              names (e.g. [["riv.cond",0],["wel.flux",1] to setup up cell-based parameters for
                              each list-type element listed.  These multiplier parameters are applied across
                              all stress periods.  For this to work, there must be the same number of entries
                              for all stress periods.  If more than one list element of the same type is in a single
                              cell, only one parameter is used to multiply all lists in the same cell.
   :type spatial_list_props: [[`str`,[`int`]]]
   :param grid_props: grid-based (every active model cell) multiplier parameters.
                      A nested list of grid-scale model properties to parameterize using
                      name, iterable pairs.  For 3D properties, the iterable is zero-based
                      layer indices (e.g., ["lpf.hk",[0,1,2,]] would setup a multiplier
                      parameter for layer property file horizontal hydraulic conductivity for model
                      layers 1,2, and 3 in every active model cell).  For time-varying properties (e.g. recharge), the
                      iterable is for zero-based stress period indices.  For example, ["rch.rech",[0,4,10,15]]
                      would setup grid-based multiplier parameters in every active model cell
                      for recharge for stress period 1,5,11,and 16.
   :type grid_props: [[`str`,[`int`]]]
   :param sfr_pars: setup parameters for the stream flow routing modflow package.
                    If list is passed it defines the parameters to set up.
   :type sfr_pars: `bool`
   :param sfr_temporal_pars: flag to include stress-period level spatially-global multipler parameters in addition to
                             the spatially-discrete `sfr_pars`.  Requires `sfr_pars` to be passed.  Default is False
   :type sfr_temporal_pars: `bool`
   :param grid_geostruct: the geostatistical structure to build the prior parameter covariance matrix
                          elements for grid-based parameters.  If None, a generic GeoStruct is created
                          using an "a" parameter that is 10 times the max cell size.  Default is None
   :type grid_geostruct: `pyemu.geostats.GeoStruct`
   :param pp_space: number of grid cells between pilot points.  If None, use the default
                    in pyemu.pp_utils.setup_pilot_points_grid.  Default is None
   :type pp_space: `int`
   :param zone_props: zone-based multiplier parameters.
                      A nested list of zone-based model properties to parameterize using
                      name, iterable pairs.  For 3D properties, the iterable is zero-based
                      layer indices (e.g., ["lpf.hk",[0,1,2,]] would setup a multiplier
                      parameter for layer property file horizontal hydraulic conductivity for model
                      layers 1,2, and 3 for unique zone values in the ibound array.
                      For time-varying properties (e.g. recharge), the iterable is for
                      zero-based stress period indices.  For example, ["rch.rech",[0,4,10,15]]
                      would setup zone-based multiplier parameters for recharge for stress
                      period 1,5,11,and 16.
   :type zone_props: [[`str`,[`int`]]]
   :param pp_geostruct: the geostatistical structure to use for building the prior parameter
                        covariance matrix for pilot point parameters.  If None, a generic
                        GeoStruct is created using pp_space and grid-spacing information.
                        Default is None
   :type pp_geostruct: `pyemu.geostats.GeoStruct`
   :param par_bounds_dict: a dictionary of model property/boundary condition name, upper-lower bound pairs.
                           For example, par_bounds_dict = {"hk":[0.01,100.0],"flux":[0.5,2.0]} would
                           set the bounds for horizontal hydraulic conductivity to
                           0.001 and 100.0 and set the bounds for flux parameters to 0.5 and
                           2.0.  For parameters not found in par_bounds_dict,
                           `pyemu.helpers.wildass_guess_par_bounds_dict` is
                           used to set somewhat meaningful bounds.  Default is None
   :type par_bounds_dict: `dict`
   :param temporal_list_geostruct: the geostastical struture to
                                   build the prior parameter covariance matrix
                                   for time-varying list-type multiplier parameters.  This GeoStruct
                                   express the time correlation so that the 'a' parameter is the length of
                                   time that boundary condition multiplier parameters are correlated across.
                                   If None, then a generic GeoStruct is created that uses an 'a' parameter
                                   of 3 stress periods.  Default is None
   :type temporal_list_geostruct: `pyemu.geostats.GeoStruct`
   :param spatial_list_geostruct: the geostastical struture to
                                  build the prior parameter covariance matrix
                                  for spatially-varying list-type multiplier parameters.
                                  If None, a generic GeoStruct is created using an "a" parameter that
                                  is 10 times the max cell size.  Default is None.
   :type spatial_list_geostruct: `pyemu.geostats.GeoStruct`
   :param remove_existing: a flag to remove an existing new_model_ws directory.  If False and
                           new_model_ws exists, an exception is raised.  If True and new_model_ws
                           exists, the directory is destroyed - user beware! Default is False.
   :type remove_existing: `bool`
   :param k_zone_dict: a dictionary of zero-based layer index, zone array pairs.
                       e.g. {lay: np.2darray}  Used to
                       override using ibound zones for zone-based parameterization.  If None,
                       use ibound values greater than zero as zones. Alternatively a dictionary of dictionaries
                       can be passed to allow different zones to be defined for different parameters.
                       e.g. {"upw.hk" {lay: np.2darray}, "extra.rc11" {lay: np.2darray}}
                       or {"hk" {lay: np.2darray}, "rc11" {lay: np.2darray}}
   :type k_zone_dict: `dict`
   :param use_pp_zones: a flag to use ibound zones (or k_zone_dict, see above) as pilot
                        point zones.  If False, ibound values greater than zero are treated as
                        a single zone for pilot points.  Default is False
   :type use_pp_zones: `bool`
   :param obssim_smp_pairs ([[`str`: a list of observed-simulated PEST-type SMP file
                                     pairs to get observations
                                     from and include in the control file.  Default is []
   :param `str`]]: a list of observed-simulated PEST-type SMP file
                   pairs to get observations
                   from and include in the control file.  Default is []
   :param external_tpl_in_pairs ([[`str`: a list of existing template file, model input
                                          file pairs to parse parameters
                                          from and include in the control file.  Default is []
   :param `str`]]: a list of existing template file, model input
                   file pairs to parse parameters
                   from and include in the control file.  Default is []
   :param external_ins_out_pairs ([[`str`: a list of existing instruction file,
                                           model output file pairs to parse
                                           observations from and include in the control file.  Default is []
   :param `str`]]: a list of existing instruction file,
                   model output file pairs to parse
                   observations from and include in the control file.  Default is []
   :param extra_pre_cmds: a list of preprocessing commands to add to the forward_run.py script
                          commands are executed with os.system() within forward_run.py. Default is None.
   :type extra_pre_cmds: [`str`]
   :param redirect_forward_output: flag for whether to redirect forward model output to text files (True) or
                                   allow model output to be directed to the screen (False).  Default is True
   :type redirect_forward_output: `bool`
   :param extra_post_cmds: a list of post-processing commands to add to the forward_run.py script.
                           Commands are executed with os.system() within forward_run.py. Default is None.
   :type extra_post_cmds: [`str`]
   :param tmp_files: a list of temporary files that should be removed at the start of the forward
                     run script.  Default is [].
   :type tmp_files: [`str`]
   :param model_exe_name: binary name to run modflow.  If None, a default from flopy is used,
                          which is dangerous because of the non-standard binary names
                          (e.g. MODFLOW-NWT_x64, MODFLOWNWT, mfnwt, etc). Default is None.
   :type model_exe_name: `str`
   :param build_prior: flag to build prior covariance matrix. Default is True
   :type build_prior: `bool`
   :param sfr_obs: flag to include observations of flow and aquifer exchange from
                   the sfr ASCII output file
   :type sfr_obs: `bool`
   :param hfb_pars: add HFB parameters.  uses pyemu.gw_utils.write_hfb_template().  the resulting
                    HFB pars have parval1 equal to the values in the original file and use the
                    spatial_list_geostruct to build geostatistical covariates between parameters
   :type hfb_pars: `bool`
   :param kl_props: karhunen-loeve based multiplier parameters.
                    A nested list of KL-based model properties to parameterize using
                    name, iterable pairs.  For 3D properties, the iterable is zero-based
                    layer indices (e.g., ["lpf.hk",[0,1,2,]] would setup a multiplier
                    parameter for layer property file horizontal hydraulic conductivity for model
                    layers 1,2, and 3 for unique zone values in the ibound array.
                    For time-varying properties (e.g. recharge), the iterable is for
                    zero-based stress period indices.  For example, ["rch.rech",[0,4,10,15]]
                    would setup zone-based multiplier parameters for recharge for stress
                    period 1,5,11,and 16.
   :type kl_props: [[`str`,[`int`]]]
   :param kl_num_eig: the number of KL-based eigenvector multiplier parameters to use for each
                      KL parameter set. default is 100
   :type kl_num_eig: `int`
   :param kl_geostruct: the geostatistical structure
                        to build the prior parameter covariance matrix
                        elements for KL-based parameters.  If None, a generic GeoStruct is created
                        using an "a" parameter that is 10 times the max cell size.  Default is None
   :type kl_geostruct: `pyemu.geostats.Geostruct`

   .. note::

      Setup up multiplier parameters for an existing MODFLOW model.
      
      Does all kinds of coolness like building a
      meaningful prior, assigning somewhat meaningful parameter groups and
      bounds, writes a forward_run.py script with all the calls need to
      implement multiplier parameters, run MODFLOW and post-process.
      
      Works a lot better if TEMPCHEK, INSCHEK and PESTCHEK are available in the
      system path variable

   .. method:: _setup_sfr_obs(self)

      setup sfr ASCII observations


   .. method:: _setup_sfr_pars(self, par_cols=None, include_temporal_pars=None)

      setup multiplier parameters for sfr segment data
      Adding support for reachinput (and isfropt = 1)


   .. method:: _setup_hfb_pars(self)

      setup non-mult parameters for hfb (yuck!)



   .. method:: _setup_mult_dirs(self)

      setup the directories to use for multiplier parameterization.  Directories
      are make within the PstFromFlopyModel.m.model_ws directory


   .. method:: _setup_model(self, model, org_model_ws, new_model_ws)

      setup the flopy.mbase instance for use with multipler parameters.
      Changes model_ws, sets external_path and writes new MODFLOW input
      files


   .. method:: _get_count(self, name)

      get the latest counter for a certain parameter type.



   .. method:: _prep_mlt_arrays(self)

      prepare multipler arrays.  Copies existing model input arrays and
      writes generic (ones) multiplier arrays


   .. method:: _write_u2d(self, u2d)

      write a flopy.utils.Util2D instance to an ASCII text file using the
      Util2D filename


   .. method:: _write_const_tpl(self, name, tpl_file, zn_array)

      write a template file a for a constant (uniform) multiplier parameter



   .. method:: _write_grid_tpl(self, name, tpl_file, zn_array)

      write a template file a for grid-based multiplier parameters



   .. method:: _grid_prep(self)

      prepare grid-based parameterizations



   .. method:: _pp_prep(self, mlt_df)

      prepare pilot point based parameterization




   .. method:: _kl_prep(self, mlt_df)

      prepare KL based parameterizations



   .. method:: _setup_array_pars(self)

      main entry point for setting up array multipler parameters



   .. method:: _setup_observations(self)

      main entry point for setting up observations



   .. method:: draw(self, num_reals=100, sigma_range=6, use_specsim=False, scale_offset=True)

      draw from the geostatistically-implied parameter covariance matrix

      :param num_reals: number of realizations to generate. Default is 100
      :type num_reals: `int`
      :param sigma_range: number of standard deviations represented by
                          the parameter bounds.  Default is 6.
      :type sigma_range: `float`
      :param use_specsim: flag to use spectral simulation for grid-based
                          parameters.  Requires a regular grid but is wicked fast.  Default is False
      :type use_specsim: `bool`
      :param scale_offset: flag to apply scale and offset to parameter
                           bounds when calculating variances - this is passed through to
                           `pyemu.Cov.from_parameter_data`.  Default is True.
      :type scale_offset: `bool`, optional

      .. note::

         operates on parameters by groups to avoid having to construct a very large
         covariance matrix for problems with more the 30K parameters.
         
         uses `helpers.geostatitical_draw()`

      :returns: The realized parameter ensemble
      :rtype: `pyemu.ParameterEnsemble`


   .. method:: build_prior(self, fmt='ascii', filename=None, droptol=None, chunk=None, sigma_range=6)

      build and optionally save the prior parameter covariance matrix.

      :param fmt: the format to save the cov matrix.  Options are "ascii","binary","uncfile", "coo".
                  Default is "ascii".  If "none" (lower case string, not None), then no file is created.
      :type fmt: `str`, optional
      :param filename: the filename to save the prior cov matrix to.  If None, the name is formed using
                       model nam_file name.  Default is None.
      :type filename: `str`, optional
      :param droptol: tolerance for dropping near-zero values when writing compressed binary.
                      Default is None.
      :type droptol: `float`, optional
      :param chunk: chunk size to write in a single pass - for binary only.  Default
                    is None (no chunking).
      :type chunk: `int`, optional
      :param sigma_range: number of standard deviations represented by the parameter bounds.  Default
                          is 6.
      :type sigma_range: `float`

      :returns: the full prior parameter covariance matrix, generated by processing parameters by
                groups
      :rtype: `pyemu.Cov`


   .. method:: build_pst(self, filename=None)

      build the pest control file using the parameters and
      observations.

      :param filename: the filename to save the contorl file to.  If None, the
                       name if formed from the model namfile name.  Default is None.  The control
                       is saved in the `PstFromFlopy.m.model_ws` directory.
      :type filename: `str`

      .. note::

         calls pyemu.Pst.from_io_files
         
         calls PESTCHEK


   .. method:: _add_external(self)

      add external (existing) template files and/or instruction files to the
      Pst instance


   .. method:: write_forward_run(self)

      write the forward run script forward_run.py

      .. note::

         This method can be called repeatedly, especially after any
         changed to the pre- and/or post-processing routines.


   .. method:: _parse_k(self, k, vals)

      parse the iterable from a property or boundary condition argument


   .. method:: _parse_pakattr(self, pakattr)

      parse package-iterable pairs from a property or boundary condition
      argument


   .. method:: _setup_list_pars(self)

      main entry point for setting up list multiplier
      parameters


   .. method:: _setup_temporal_list_pars(self)


   .. method:: _setup_spatial_list_pars(self)


   .. method:: _list_helper(self, k, pak, attr, col)

      helper to setup list multiplier parameters for a given
      k, pak, attr set.


   .. method:: _setup_hds(self)

      setup modflow head save file observations for given kper (zero-based
      stress period index) and k (zero-based layer index) pairs using the
      kperk argument.


   .. method:: _setup_smp(self)

      setup observations from PEST-style SMP file pairs



   .. method:: _setup_hob(self)

      setup observations from the MODFLOW HOB package


   .. method:: _setup_hyd(self)

      setup observations from the MODFLOW HYDMOD package


   .. method:: _setup_water_budget_obs(self)

      setup observations from the MODFLOW list file for
      volume and flux water buget information



.. function:: apply_list_and_array_pars(arr_par_file='mult2model_info.csv', chunk_len=50)

   Apply multiplier parameters to list and array style model files

   :param arr_par_file:
   :type arr_par_file: str
   :param chunk_len: the number of files to process per multiprocessing
                     chunk in appl_array_pars().  default is 50.
   :type chunk_len: `int`

   Returns:

   .. note::

      Used to implement the parameterization constructed by
      PstFrom during a forward run
      
      Should be added to the forward_run.py script


.. function:: _process_chunk_fac2real(chunk, i)


.. function:: _process_chunk_model_files(chunk, i, df)


.. function:: _process_model_file(model_file, df)


.. function:: apply_array_pars(arr_par='arr_pars.csv', arr_par_file=None, chunk_len=50)

   a function to apply array-based multipler parameters.

   :param arr_par: if type `str`,
   :type arr_par: `str` or `pandas.DataFrame`
   :param path to csv file detailing parameter array multipliers.: This file can be written by PstFromFlopy.
   :param if type `pandas.DataFrame` is Dataframe with columns of:
   :param ['mlt_file':
   :param 'model_file':
   :param 'org_file'] and optionally:
   :param ['pp_file':
   :param 'fac_file'].:
   :param chunk_len: the number of files to process per chunk
                     with multiprocessing - applies to both fac2real and process_
                     input_files. Default is 50.
   :type chunk_len: `int`

   .. note::

      Used to implement the parameterization constructed by
      PstFromFlopyModel during a forward run
      
      This function should be added to the forward_run.py script but can
      be called on any correctly formatted csv
      
      This function using multiprocessing, spawning one process for each
      model input array (and optionally pp files).  This speeds up
      execution time considerably but means you need to make sure your
      forward run script uses the proper multiprocessing idioms for
      freeze support and main thread handling.


.. function:: apply_list_pars()

   a function to apply boundary condition multiplier parameters.

   .. note::

      Used to implement the parameterization constructed by
      PstFromFlopyModel during a forward run
      
      Requires either "temporal_list_pars.csv" or "spatial_list_pars.csv"
      
      Should be added to the forward_run.py script


.. function:: apply_genericlist_pars(df)

   a function to apply list style mult parameters

   :param df: DataFrame that relates files containing
              multipliers to model input file names. Required columns include:
              {"model_file": file name of resulatant model input file,
              "org_file": file name of original file that multipliers act on,
              "fmt": format specifier for model input file (currently on 'free' supported),
              "sep": separator for model input file if 'free' formatted,
              "head_rows": Number of header rows to transfer from orig file to model file,
              "index_cols": list of columns (either indexes or strings) to be used to align mults, orig and model files,
              "use_cols": columns to mults act on,
              "upper_bound": ultimate upper bound for model input file parameter,
              "lower_bound": ultimate lower bound for model input file parameter}
   :type df: pandas.DataFrame


.. function:: write_const_tpl(name, tpl_file, suffix, zn_array=None, shape=None, longnames=False)

   write a constant (uniform) template file for a 2-D array

   :param name: the base parameter name
   :type name: `str`
   :param tpl_file: the template file to write
   :type tpl_file: `str`
   :param zn_array: an array used to skip inactive cells,
                    and optionally get shape info.
   :type zn_array: `numpy.ndarray`, optional
   :param shape: tuple nrow and ncol.  Either `zn_array` or `shape`
                 must be passed
   :type shape: `tuple`
   :param longnames: flag to use longer names that exceed 12 chars in length.
                     Default is False.
   :type longnames: `bool`

   :returns: a dataframe with parameter information
   :rtype: `pandas.DataFrame`


.. function:: write_grid_tpl(name, tpl_file, suffix, zn_array=None, shape=None, spatial_reference=None, longnames=False)

   write a grid-based template file for a 2-D array

   :param name: the base parameter name
   :type name: `str`
   :param tpl_file: the template file to write - include path
   :type tpl_file: `str`
   :param zn_array: zone array to identify
                    inactive cells.  Default is None
   :type zn_array: `numpy.ndarray`, optional
   :param shape: a length-two tuple of nrow and ncol.  Either
                 `zn_array` or `shape` must be passed.
   :type shape: `tuple`, optional
   :param spatial_reference: a spatial reference instance.
                             If `longnames` is True, then `spatial_reference` is used to add spatial info
                             to the parameter names.
   :type spatial_reference: `flopy.utils.SpatialReference`
   :param longnames: flag to use longer names that exceed 12 chars in length.
                     Default is False.
   :type longnames: `bool`

   :returns: a dataframe with parameter information
   :rtype: `pandas.DataFrame`


.. function:: write_zone_tpl(name, tpl_file, suffix='', zn_array=None, shape=None, longnames=False, fill_value='1.0')

   write a zone-based template file for a 2-D array

   :param name: the base parameter name
   :type name: `str`
   :param tpl_file: the template file to write
   :type tpl_file: `str`
   :param suffix: suffix to add to parameter names.  Only used if `longnames=True`
   :type suffix: `str`
   :param zn_array: an array used to skip inactive cells,
                    and optionally get shape info.  zn_array values less than 1 are given `fill_value`
   :type zn_array: `numpy.ndarray`, optional
   :param shape: tuple nrow and ncol.  Either `zn_array` or `shape`
                 must be passed
   :type shape: `tuple`
   :param longnames: flag to use longer names that exceed 12 chars in length.
                     Default is False.
   :type longnames: `bool`
   :param fill_value: value to fill locations where `zn_array` is less than 1.0.
                      Default is "1.0".
   :type fill_value: `str`

   :returns: a dataframe with parameter information
   :rtype: `pandas.DataFrame`


.. function:: build_jac_test_csv(pst, num_steps, par_names=None, forward=True)

   build a dataframe of jactest inputs for use with sweep

   :param pst: existing control file
   :type pst: `pyemu.Pst`
   :param num_steps: number of pertubation steps for each parameter
   :type num_steps: `int`
   :param par_names [`str`]: list of parameter names of pars to test.
                             If None, all adjustable pars are used. Default is None
   :param forward: flag to start with forward pertubations.
                   Default is True
   :type forward: `bool`

   :returns: the sequence of model runs to evaluate
             for the jactesting.
   :rtype: `pandas.DataFrame`


.. function:: _write_df_tpl(filename, df, sep=',', tpl_marker='~', **kwargs)

   function write a pandas dataframe to a template file.



.. function:: setup_fake_forward_run(pst, new_pst_name, org_cwd='.', bak_suffix='._bak', new_cwd='.')

   setup a fake forward run for a pst.

   :param pst: existing control file
   :type pst: `pyemu.Pst`
   :param new_pst_name: new control file to write
   :type new_pst_name: `str`
   :param org_cwd: existing working dir.  Default is "."
   :type org_cwd: `str`
   :param bak_suffix: suffix to add to existing
                      model output files when making backup copies.
   :type bak_suffix: `str`, optional
   :param new_cwd: new working dir.  Default is ".".
   :type new_cwd: `str`

   .. note::

      The fake forward run simply copies existing backup versions of
      model output files to the outfiles pest(pp) is looking
      for.  This is really a development option for debugging
      PEST++ issues.


.. function:: setup_temporal_diff_obs(pst, ins_file, out_file=None, include_zero_weight=False, include_path=False, sort_by_name=True, long_names=True, prefix='dif')

   a helper function to setup difference-in-time observations based on an existing
   set of observations in an instruction file using the observation grouping in the
   control file

   :param pst: existing control file
   :type pst: `pyemu.Pst`
   :param ins_file: an existing instruction file
   :type ins_file: `str`
   :param out_file: an existing model output file that corresponds to
                    the instruction file.  If None, `ins_file.replace(".ins","")` is used
   :type out_file: `str`, optional
   :param include_zero_weight: flag to include zero-weighted observations
                               in the difference observation process.  Default is False so that only non-zero
                               weighted observations are used.
   :type include_zero_weight: `bool`, optional
   :param include_path: flag to setup the binary file processing in directory where the hds_file
                        is located (if different from where python is running).  This is useful for setting up
                        the process in separate directory for where python is running.
   :type include_path: `bool`, optional
   :param sort_by_name: flag to sort observation names in each group prior to setting up
                        the differencing.  The order of the observations matters for the differencing.  If False, then
                        the control file order is used.  If observation names have a datetime suffix, make sure the format is
                        year-month-day to use this sorting.  Default is True
   :type sort_by_name: `bool`,optional
   :param long_names: flag to use long, descriptive names by concating the two observation names
                      that are being differenced.  This will produce names that are too long for tradtional PEST(_HP).
                      Default is True.
   :type long_names: `bool`, optional
   :param prefix: prefix to prepend to observation names and group names.  Default is "dif".
   :type prefix: `str`, optional

   :returns: tuple containing

             - **str**: the forward run command to execute the binary file process during model runs.

             - **pandas.DataFrame**: a dataframe of observation information for use in the pest control file

   .. note:: this is the companion function of `helpers.apply_temporal_diff_obs()`.


.. function:: apply_temporal_diff_obs(config_file)

   process an instruction-output file pair and formulate difference observations.

   :param config_file: configuration file written by `pyemu.helpers.setup_temporal_diff_obs`.
   :type config_file: `str`

   :returns: processed difference observations
   :rtype: diff_df (`pandas.DataFrame`)

   .. note::

      writes `config_file.replace(".config",".processed")` output file that can be read
      with the instruction file that is created by `pyemu.helpers.setup_temporal_diff_obs()`.
      
      this is the companion function of `helpers.setup_setup_temporal_diff_obs()`.


.. data:: srefhttp
   :annotation: = https://spatialreference.org

   

.. py:class:: SpatialReference(delr=np.array([]), delc=np.array([]), lenuni=2, xul=None, yul=None, xll=None, yll=None, rotation=0.0, proj4_str=None, epsg=None, prj=None, units=None, length_multiplier=None, source=None)

   Bases: :class:`object`

   a class to locate a structured model grid in x-y space.
   Lifted wholesale from Flopy, and preserved here...
   ...maybe slighlty over-engineered for here

   :param delr: the model discretization delr vector
                (An array of spacings along a row)
   :type delr: numpy ndarray
   :param delc: the model discretization delc vector
                (An array of spacings along a column)
   :type delc: numpy ndarray
   :param lenuni: the length units flag from the discretization package
                  (default 2)
   :type lenuni: int
   :param xul: the x coordinate of the upper left corner of the grid
               Enter either xul and yul or xll and yll.
   :type xul: float
   :param yul: the y coordinate of the upper left corner of the grid
               Enter either xul and yul or xll and yll.
   :type yul: float
   :param xll: the x coordinate of the lower left corner of the grid
               Enter either xul and yul or xll and yll.
   :type xll: float
   :param yll: the y coordinate of the lower left corner of the grid
               Enter either xul and yul or xll and yll.
   :type yll: float
   :param rotation: the counter-clockwise rotation (in degrees) of the grid
   :type rotation: float
   :param proj4_str: a PROJ4 string that identifies the grid in space. warning: case
                     sensitive!
   :type proj4_str: str
   :param units: Units for the grid.  Must be either feet or meters
   :type units: string
   :param epsg: EPSG code that identifies the grid in space. Can be used in lieu of
                proj4. PROJ4 attribute will auto-populate if there is an internet
                connection(via get_proj4 method).
                See https://www.epsg-registry.org/ or spatialreference.org
   :type epsg: int
   :param length_multiplier: multiplier to convert model units to spatial reference units.
                             delr and delc above will be multiplied by this value. (default=1.)
   :type length_multiplier: float

   .. attribute:: xedge

      array of column edges

      :type: ndarray

   .. attribute:: yedge

      array of row edges

      :type: ndarray

   .. attribute:: xgrid

      numpy meshgrid of xedges

      :type: ndarray

   .. attribute:: ygrid

      numpy meshgrid of yedges

      :type: ndarray

   .. attribute:: xcenter

      array of column centers

      :type: ndarray

   .. attribute:: ycenter

      array of row centers

      :type: ndarray

   .. attribute:: xcentergrid

      numpy meshgrid of column centers

      :type: ndarray

   .. attribute:: ycentergrid

      numpy meshgrid of row centers

      :type: ndarray

   .. attribute:: vertices

      1D array of cell vertices for whole grid in C-style (row-major) order
      (same as np.ravel())

      :type: 1D array

   .. rubric:: Notes

   xul and yul can be explicitly (re)set after SpatialReference
   instantiation, but only before any of the other attributes and methods are
   accessed

   .. attribute:: rotation
      :annotation: = 0.0

      

   .. attribute:: length_multiplier
      :annotation: = 1.0

      

   .. attribute:: origin_loc
      :annotation: = ul

      

   .. attribute:: defaults
      

      

   .. attribute:: lenuni_values
      

      

   .. attribute:: lenuni_text
      

      

   .. method:: xll(self)
      :property:


   .. method:: yll(self)
      :property:


   .. method:: xul(self)
      :property:


   .. method:: yul(self)
      :property:


   .. method:: proj4_str(self)
      :property:


   .. method:: epsg(self)
      :property:


   .. method:: lenuni(self)
      :property:


   .. method:: _parse_units_from_proj4(self)


   .. method:: units(self)
      :property:


   .. method:: length_multiplier(self)
      :property:

      Attempt to identify multiplier for converting from
      model units to sr units, defaulting to 1.


   .. method:: model_length_units(self)
      :property:


   .. method:: bounds(self)
      :property:

      Return bounding box in shapely order.


   .. method:: load(namefile=None, reffile='usgs.model.reference')
      :staticmethod:

      Attempts to load spatial reference information from
      the following files (in order):
      1) usgs.model.reference
      2) NAM file (header comment)
      3) SpatialReference.default dictionary


   .. method:: attribs_from_namfile_header(namefile)
      :staticmethod:


   .. method:: read_usgs_model_reference_file(reffile='usgs.model.reference')
      :staticmethod:

      read spatial reference info from the usgs.model.reference file
      https://water.usgs.gov/ogw/policy/gw-model/modelers-setup.html


   .. method:: __setattr__(self, key, value)

      Implement setattr(self, name, value).


   .. method:: reset(self, **kwargs)


   .. method:: _reset(self)


   .. method:: nrow(self)
      :property:


   .. method:: ncol(self)
      :property:


   .. method:: __eq__(self, other)

      Return self==value.


   .. method:: from_namfile(cls, namefile, delr=np.array([]), delc=np.array([]))
      :classmethod:


   .. method:: from_gridspec(cls, gridspec_file, lenuni=0)
      :classmethod:


   .. method:: attribute_dict(self)
      :property:


   .. method:: set_spatialreference(self, xul=None, yul=None, xll=None, yll=None, rotation=0.0)

      set spatial reference - can be called from model instance


   .. method:: __repr__(self)

      Return repr(self).


   .. method:: theta(self)
      :property:


   .. method:: xedge(self)
      :property:


   .. method:: yedge(self)
      :property:


   .. method:: xgrid(self)
      :property:


   .. method:: ygrid(self)
      :property:


   .. method:: xcenter(self)
      :property:


   .. method:: ycenter(self)
      :property:


   .. method:: ycentergrid(self)
      :property:


   .. method:: xcentergrid(self)
      :property:


   .. method:: _set_xycentergrid(self)


   .. method:: _set_xygrid(self)


   .. method:: rotate(x, y, theta, xorigin=0.0, yorigin=0.0)
      :staticmethod:

      Given x and y array-like values calculate the rotation about an
      arbitrary origin and then return the rotated coordinates.  theta is in
      degrees.


   .. method:: transform(self, x, y, inverse=False)

      Given x and y array-like values, apply rotation, scale and offset,
      to convert them from model coordinates to real-world coordinates.


   .. method:: get_extent(self)

      Get the extent of the rotated and offset grid

      Return (xmin, xmax, ymin, ymax)


   .. method:: get_grid_lines(self)

      Get the grid lines as a list


   .. method:: get_xcenter_array(self)

      Return a numpy one-dimensional float array that has the cell center x
      coordinate for every column in the grid in model space - not offset or rotated.


   .. method:: get_ycenter_array(self)

      Return a numpy one-dimensional float array that has the cell center x
      coordinate for every row in the grid in model space - not offset of rotated.


   .. method:: get_xedge_array(self)

      Return a numpy one-dimensional float array that has the cell edge x
      coordinates for every column in the grid in model space - not offset
      or rotated.  Array is of size (ncol + 1)


   .. method:: get_yedge_array(self)

      Return a numpy one-dimensional float array that has the cell edge y
      coordinates for every row in the grid in model space - not offset or
      rotated. Array is of size (nrow + 1)


   .. method:: write_gridspec(self, filename)

      write a PEST-style grid specification file


   .. method:: get_vertices(self, i, j)

      Get vertices for a single cell or sequence if i, j locations.


   .. method:: get_rc(self, x, y)


   .. method:: get_ij(self, x, y)

      Return the row and column of a point or sequence of points
      in real-world coordinates.

      :param x:
      :type x: scalar or sequence of x coordinates
      :param y:
      :type y: scalar or sequence of y coordinates

      :returns: * **i** (*row or sequence of rows (zero-based)*)
                * **j** (*column or sequence of columns (zero-based)*)


   .. method:: vertices(self)
      :property:

      Returns a list of vertices for


   .. method:: _set_vertices(self)

      Populate vertices for the whole grid



.. function:: get_maha_obs_summary(sim_en, l1_crit_val=6.34, l2_crit_val=9.2)

   calculate the 1-D and 2-D mahalanobis distance

   :param sim_en: a simulated outputs ensemble
   :type sim_en: `pyemu.ObservationEnsemble`
   :param l1_crit_val: the chi squared critical value for the 1-D
                       mahalanobis distance.  Default is 6.4 (p=0.01,df=1)
   :type l1_crit_val: `float`
   :param l2_crit_val: the chi squared critical value for the 2-D
                       mahalanobis distance.  Default is 9.2 (p=0.01,df=2)
   :type l2_crit_val: `float`

   :returns: tuple containing

             - **pandas.DataFrame**: 1-D subspace squared mahalanobis distances
                 that exceed the `l1_crit_val` threshold
             - **pandas.DataFrame**: 2-D subspace squared mahalanobis distances
                 that exceed the `l2_crit_val` threshold

   .. note::

      Noise realizations are added to `sim_en` to account for measurement
          noise.


.. function:: _l2_maha_worker(o1, o2names, mean, var, cov, results, l2_crit_val)


